<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Sweetyxz"><title>【Web安全】白帽子讲web安全笔记 · Sweetyxz</title><meta name="description" content="浏览器安全
同源策略

同源策略限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性

同源是指：协议，域名，端口号相同

js文件的源是加载他的域

对于浏览器来说，除了DOM，Cookie，XMLHttpRequest会受到同源策略限制外，一些第三方插件也有"><meta name="keywords" content="Blog"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Sweetyxz</a></h3><div class="description"><p>少就是多 慢就是快</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Sweetyxz"><i class="fa fa-github"></i></a></li><li><a href="mailto:2364539601@qq.com"><i class="fa fa-envelope"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Sweetyxz</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>【Web安全】白帽子讲web安全笔记</a></h3></div><div class="post-content"><p><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><ul>
<li><p>同源策略</p>
<ul>
<li><p>同源策略限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性</p>
</li>
<li><p>同源是指：协议，域名，端口号相同</p>
</li>
<li><p>js文件的源是加载他的域</p>
</li>
<li><p>对于浏览器来说，除了DOM，Cookie，XMLHttpRequest会受到同源策略限制外，一些第三方插件也有自己的同源策略，如Flash，Google Gears</p>
</li>
</ul>
</li>
<li><p>浏览器沙箱</p>
<ul>
<li><p>挂马：在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式</p>
</li>
<li><p>浏览器多进程架构，将浏览器各个功能隔开。</p>
</li>
<li><p>google主要进程分为浏览器进程，渲染进程，插件进程，扩展进程。渲染引擎由Sandbox隔离，页面代码要与浏览器内核进程通信、操作系统通信都需要通过IPC channel</p>
</li>
<li><p>Sandbox：泛指“资源隔离类模块”，设计目的是为了让不信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源，如要跨越沙箱边界产生数据交换，只能通过指定数据通道，比如经过封装的API</p>
</li>
<li><p>采用沙箱技术，可以让不受信任的网页代码、js代码运行在一个受到限制的环境中，保护本地桌面系统安全。</p>
</li>
</ul>
</li>
<li><p>恶意网址拦截</p>
<ul>
<li><p>拦截恶意网站的功能是基于黑名单的</p>
</li>
<li><p>常见的恶意网站</p>
<ul>
<li><p>挂马网站：包含恶意脚本如js或flash，通过利用浏览器漏洞，执行shellcode，在用户电脑植入木马</p>
</li>
<li><p>钓鱼网站：通过模仿知名网站的相似页面来欺骗用户</p>
</li>
</ul>
</li>
<li><p>EVSSL证书：全球数据证书颁发机构与浏览器厂商一起打造的增强型证书。浏览器会给于EVSSL证书特殊待遇</p>
</li>
</ul>
</li>
</ul>
<h2 id="跨站脚本攻击（xss）（未完）"><a href="#跨站脚本攻击（xss）（未完）" class="headerlink" title="跨站脚本攻击（xss）（未完）"></a>跨站脚本攻击（xss）（未完）</h2><ul>
<li><p>XSS简介</p>
<p>XSS攻击通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。</p>
<ul>
<li><p>反射型XSS：简单的把用户输入的数据“反射”给浏览器，即黑客需要诱使用户“点击”一个恶意链接，才能攻击成功。“非持久型xss”</p>
</li>
<li><p>存储型XSS：将用户输入的数据“存储”在服务器端，这种xss具有很强的稳定性</p>
</li>
<li><p>DOM Based XSS：修改页面的DOM节点形成的XSS</p>
</li>
</ul>
</li>
<li><p>XSS防御</p>
<ul>
<li><p>HttpOnly</p>
<ul>
<li><p>在服务器发送set-cookie时标记，设置之后js读不到cookie值</p>
</li>
<li><p>解决的是XSS后的cookie劫持攻击</p>
</li>
</ul>
</li>
<li><p>输入检查</p>
<p>一般是检查用户输入的数据中是否包含一些特殊字符-xss Filter ​</p>
<ul>
<li><p>有时候过滤会过滤掉用户本身的输入信息</p>
</li>
<li><p>当用户将恶意脚本的url输入时，无法filter，url被认为是合法的</p>
</li>
</ul>
</li>
<li><p>输出检查</p>
<p>在变量输出到HTML页面时，可以使用编码或者转义字符来防御XSS ​</p>
<ul>
<li><p>安全的编码函数</p>
<ul>
<li><p>HtmlEncode：针对HTML的编码方式。会对&amp; 〈 等字符进行转换，PHP中htmlentities()和htmlspecialchars()函数可以满足安全要求</p>
</li>
<li><p>JS中使用JavascriptEncode进行编码，使用\进行转义，并要求输出的变量在引号内部</p>
</li>
</ul>
</li>
<li><p>并不是在MVC的View层HtmlEncode所有变量就可以抵御XSS，XSS的防御需要分情况对待。</p>
</li>
</ul>
</li>
<li><p>针对XSS可能发生的场景一一应对</p>
<p>xss本质是一种HTML注入，用户的数据被当成了HTML代码的一部分来执行，从而产生了新的语义。</p>
<ul>
<li><p>在HTML标签中输出变量</p>
<ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/3ff7a7f0-bad7-4bcd-9b90-757211e7c2a4-12056492.jpg"></p>
</li>
<li><p>可能攻击方式：xss一般会构造一个<script>标签，或者任何能够产生脚本执行的方式：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/9469d8e7-fc21-4575-acb9-a859191fa542-12056492.jpg"></li>
</ul>
</li>
<li><p>防御方法：对变量使用HtmlEncode</p>
</li>
</ul>
</li>
<li><p>在HTML属性中输出变量</p>
<ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/64ca9977-b43b-485b-8f30-6d663040ce72-12056492.jpg"></p>
</li>
<li><p>可能攻击方式：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/dfd7d2d4-82cb-4157-9593-dfb5062925ec-12056492.jpg"></li>
</ul>
</li>
<li><p>防御方式：HtmlEncode 还有OWASP ESAPI推荐的更严格的HtmlEncode，即除字母数字外，所有特殊字符都被编码成HTMLEntities</p>
</li>
</ul>
</li>
<li><p>在<script>标签中输出</p>
<ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/49e736cf-bb0e-4aa5-a6ca-c5f4f9c796f0-12056492.jpg"></p>
</li>
<li><p>可能攻击方式：攻击者将引号闭合</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/fc2d0f5f-b55b-4cbd-b4d8-ebffef0e6791-12056492.jpg"></li>
</ul>
</li>
<li><p>防御方式：JavascriptEncode</p>
</li>
</ul>
</li>
<li><p>在CSS中输出</p>
<ul>
<li><p>可能攻击方式：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/f519e0f5-2aa5-4864-9b78-3553134b0af2-12056492.jpg"></li>
</ul>
</li>
<li><p>防御方式：尽可能禁止用户可控制的变量在<style>标签、HTML标签的style属性以及CSS文件中输出；还可以使用OWASP ESAPI中的encodeForCSS()函数</p>
</li>
</ul>
</li>
<li><p>在地址中输出</p>
<ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/d7a3d604-cee7-44b1-935b-c672bbae6625-12056492.jpg"></p>
</li>
<li><p>可能攻击方式：如果用户能够控制整个url，则可以构造伪协议</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/11d499f6-0650-4265-82b9-bffffb31a9c2-12056492.jpg"></li>
</ul>
</li>
<li><p>防御方式：如果变量是整个url，则先检查变量是否以"http"开头，若不是则自动添加，在此之后再对变量进行URLEncode</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>处理富文本</p>
<p>网站需要用户提交自定义的HTML代码，称为富文本。比如在论坛中发帖子需要文字，图片视频，表格等。</p>
<ul>
<li><p>过滤富文本时，“事件”应该被禁止，还有一些危险的标签，例如<iframe>, <script>, <base>, <form>等。使用“白名单”原则，比如只允许<a>, <img> <div> 等比较安全的标签存在</p>
</li>
<li><p>开源的XSS Filter：Anti-Samy，HTMLPurify</p>
</li>
</ul>
</li>
<li><p>防御DOM Based XSS</p>
</li>
</ul>
</li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><ul>
<li><p>简介</p>
<ul>
<li>在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为"one click"攻击。</li>
</ul>
</li>
<li><p>进阶</p>
<ul>
<li><p>浏览器的cookie策略</p>
<ul>
<li><p>session cookie：临时cookie，浏览器关闭后，session cookie就会失效</p>
</li>
<li><p>third-party cookie：本地cookie，服务器在set-cookie时会指定Expire时间，到了时间cookie才会失效。</p>
</li>
</ul>
</li>
<li><p>P3P头</p>
<ul>
<li>P3P头主要用于类似广告等需要跨域访问的页面。如果网站返回给浏览器的HTTP头中含有P3P头，则在某种程度上，将允许浏览器发送第三方cookie。（有些浏览器会拦截第三方cookie的发送，如IE和safari）</li>
</ul>
</li>
<li><p>csrf-get</p>
<ul>
<li><p>对于一个表单来说，用户往往可以使用GET提交参数，例如：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/767faea5-b57a-4064-bdb3-a937d64894ed-12056492.jpg"></li>
</ul>
</li>
<li><p>攻击者可以构建如下html界面，让有登录状态的用户点击，即可造成csrf攻击</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/abbfb2f4-a7ad-474e-8a07-4ddcc7d34444-12056492.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>csrf-post</p>
<ul>
<li><p>当网页使用POST方法时，例如：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/8ec59ab1-a202-4551-aca2-964b021dc811-12056492.jpg"></li>
</ul>
</li>
<li><p>可以直接构造form表单，然后用js自动化提交表单</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/576c5b16-a6d7-404b-a9b6-e9ce414b9f21-12056492.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>防御</p>
<ul>
<li><p>验证码</p>
<ul>
<li>CSRF攻击的过程往往是在用户不知情的情况构成了网络请求，但验证码强制要求用户必须与应用进行交互。但是用户体验不佳</li>
</ul>
</li>
<li><p>Referer Check</p>
<ul>
<li><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a target="_blank" rel="noopener" href="http://a.example/b%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E9%99%86">http://a.example/b，用户必须先登陆</a> a.example，然后通过点击页面上的按钮来触发事件。这时，该请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 a.example 域名开头的地址。而如果黑客要对网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，网站只需要对于每一个请求验证其 Referer 值，如果是以 a.example 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
</li>
<li><p>缺点是服务器并非任何时候都能取到Referer，很多用户出于隐私考虑会限制Referer的发送。另外浏览器当从HTTPS转为HTTP时，也不会发送Referer</p>
</li>
</ul>
</li>
<li><p>Anti CSRF Token</p>
<ul>
<li>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li>
</ul>
</li>
<li><p>在 HTTP 头中自定义属性并验证</p>
<ul>
<li><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
</li>
<li><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="点击劫持（Click-Jacking）"><a href="#点击劫持（Click-Jacking）" class="headerlink" title="点击劫持（Click Jacking）"></a>点击劫持（Click Jacking）</h2><ul>
<li><p>点击劫持（ClickJacking）是一种视觉上的欺骗手段。大概有两种方式，点击劫持（ClickJacking）是一种视觉上的欺骗手段。大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面；二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义；</p>
</li>
<li><p>防御</p>
<ul>
<li><p>frame busting</p>
<ul>
<li><p>通常可以写一段js代码来禁止iframe的嵌套，比如：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/eb36ac51-bf66-474f-96fd-16b021973a73-12056492.jpg"></li>
</ul>
</li>
<li><p>但有时候可以通过很多方式绕过，比如针对parent.location的，可以采用嵌套iframe的方式：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/3fe4191a-7a84-47fa-a5a2-26d9c96d9cc4-12056492.jpg"></li>
<li><img src="https://api2.mubu.com/v3/document_image/14880004-42c0-4055-bdfc-d243255a8e12-12056492.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>X-Frame-Options</p>
<ul>
<li><p>使用一个HTTP头——X-Frame-Options。X-Frame-Options可以说是为了解决ClickJacking而生的，它有三个可选的值：</p>
<ul>
<li><p>DENY：浏览器会拒绝当前页面加载任何frame页面；</p>
</li>
<li><p>SAMEORIGIN：frame页面的地址只能为同源域名下的页面；</p>
</li>
<li><p>ALLOW-FROM origin：允许frame加载的页面地址；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对于图片覆盖</p>
<ul>
<li>在防御图片覆盖攻击时，需要检查用户提交的HTML代码中，img标签的style属性是否可能导致浮出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="注入攻击（未完）"><a href="#注入攻击（未完）" class="headerlink" title="注入攻击（未完）"></a>注入攻击（未完）</h2><ul>
<li><p>本质</p>
<ul>
<li><p>用户可以控制输入</p>
</li>
<li><p>原本程序要执行的代码，拼接了用户输入的数据。</p>
</li>
</ul>
</li>
<li><p>SQL注入</p>
<ul>
<li>在SQL注入过程中，如果网站开启了错误回显，会为攻击者提供极大的便利（即输入非法数据，返回错误信息）</li>
</ul>
</li>
<li><p>盲注</p>
<ul>
<li><p>通过简单的条件判断等等方式判断注入是否存在</p>
</li>
<li><p>比如构造：</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/9c04606f-aed1-459c-8615-9b3bf85e9646-12056492.jpg"></li>
</ul>
</li>
<li><p>只输入2时页面正常显示，加上1=2后页面无法正常显示，即可能存在注入，此时也可能是网页的非法输入机制导致无法显示网页，再次构造，如果页面此时正常显示了，说明and语句执行了，存在注入</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/0bf135ce-0afe-4e04-81b0-ff6787f7f0f6-12056492.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>Timing Attack</p>
<ul>
<li>在MySQL中，有一个BENCHMARK()函数，用来测试函数性能。比如BENCHMARK(count,expr) 函数执行的结果是将表达式expr执行count次，比如：select benchmark( 5000000, md5( 'test' ) ); 返回结果是0，耗时1.157秒。</li>
</ul>
</li>
</ul>
<h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><ul>
<li><p>概述</p>
<ul>
<li><p>文件上传漏洞是指用户上传了一个可执行的脚本文件，通过脚本获取了执行服务端命令的能力</p>
</li>
<li><p>文件上传后导致的常见安全问题有：</p>
<ul>
<li><p>上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行；</p>
</li>
<li><p>上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似）；</p>
</li>
<li><p>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行；</p>
</li>
<li><p>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</p>
</li>
</ul>
</li>
<li><p>在大多数情况下，文件上传漏洞一般都是指“上传Web脚本能够被服务器解析”的问题，也就是通常所说的webshell的问题。要完成这个攻击，要满足如下几个条件：</p>
<ul>
<li><p>首先，上传的文件能够被Web容器解释执行。所以文件上传后所在的目录要是Web容器所覆盖到的路径。</p>
</li>
<li><p>其次，用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法使得Web容器解释这个脚本，那么也不能称之为漏洞。</p>
</li>
<li><p>最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功</p>
</li>
</ul>
</li>
<li><p>FCKEditor文件上传漏洞</p>
<ul>
<li>通过检查文件后缀确定是否安全，（以黑名单的方式），黑名单是不好的设计思想</li>
</ul>
</li>
<li><p>绕过文件上传检查</p>
<ul>
<li><p>在针对上传文件的检查中，很多应用都是通过判断文件名后缀的方法来验证文件的安全性的。但是在某些时候，如果攻击者手动修改了上传过程的POST包，在文件名后添加一个%00字节，则可以截断某些函数对文件名的判断。因为在许多语言的函数中，比如在C、PHP等语言的常用字符串处理函数中，0x00被认为是终止符。</p>
<ul>
<li>比如应用原本只允许上传JPG图片，那么可以构造文件名（需要修改POST包）为xxx.php[\0].JPG，其中[\0]为十六进制的0x00字符，.JPG绕过了应用的上传文件类型判断；但对于服务器端来说，此文件因为0字节截断的关系，最终却会变成xxx.php</li>
</ul>
</li>
<li><p>有的应用，还会通过判断上传文件的文件头来验证文件的类型。浏览器的MINE Sniff功能就是通过读取文件的前256个字节来判断文件类型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有些漏洞是因为web server本身特性相关的功能导致的</p>
<ul>
<li><p>Apache 1.x 2.x对文件名的解析是从后往前的直到遇到Apache认识的文件类型为止。这就会导致a.php.rar.rar.rar中，Apache不认识rar，会一直遍历到php</p>
</li>
<li><p>IIS 6在文件解析时，当文件名为abc.asp;xx.jpg时，IIS会解析为abc.asp，文件名被截断了，导致脚本执行。</p>
</li>
<li><p>IIS支持PUT功能导致的上传脚本问题</p>
<ul>
<li><p>PUT是在WebDav中定义的一个方法。WebDav大大扩展了HTTP协议中GET、POST、HEAD等功能，它所包含的PUT方法，允许用户上传文件到指定的路径下。</p>
</li>
<li><p>一般要实施此攻击过程，攻击者应先通过OPTIONS方法探测服务器支持的HTTP方法类型，如果支持PUT，则使用PUT上传一个指定的文本文件，最后再通过MOVE改写文件名称为脚本文件，如txt变php。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设计安全的文件上传功能</p>
<ul>
<li><p>1. 文件上传的目录设置为不可执行</p>
<ul>
<li>只要Web容器无法解析该目录下的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此此点至关重要。在实际应用中，很多大型网站的上传应用，文件上传后会放到独立的存储上，做静态文件处理，一方面方便使用缓存加速，降低性能损耗；另一方面也杜绝了脚本执行的可能。但是对于一些边边角角的小应用，如果存在文件上传功能，则仍需要多加关注。</li>
</ul>
</li>
<li><p>2．判断文件类型</p>
<ul>
<li>在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单的方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。</li>
</ul>
</li>
<li><p>3．使用随机数改写文件名和文件路径</p>
<ul>
<li>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用使用随机数改写了文件名和路径，将极大地增加攻击的成本。与此同时，像shell.php.rar.rar这种文件，或者是crossdomain.xml这种文件，都将因为文件名被改写而无法成功实施攻击。</li>
</ul>
</li>
<li><p>4．单独设置文件服务器的域名</p>
<ul>
<li>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含JavaScript的XSS利用等问题将得到解决。但能否如此设置，还需要看具体的业务环境。</li>
</ul>
</li>
</ul>
</li>
</ul>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: Sweetyxz</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-04</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Web安全/" title="Web安全">Web安全 </a><span class="leancloud_visitors"></span><span>About 4915 words, 16 min 23 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2021/07/04/白帽子/,Sweetyxz,【Web安全】白帽子讲web安全笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/07/05/firmup/" title="【论文】firmup">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/06/23/Python/" title="【Python】Python基础知识">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>