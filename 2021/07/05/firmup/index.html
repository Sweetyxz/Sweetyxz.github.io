<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Sweetyxz"><title>【论文】firmup · Sweetyxz</title><meta name="description" content="我们提出了一种新的二进制代码搜索技术，可以平衡查询过程和它所在的可执行文件之间的焦点。该方法基于稳健的底层语义过程相似性，并利用了我们的关键观察结果，即过程在其可执行文件的上下文中操作。
我们提出了一种算法，用来使用可执行文件中的周围过程，通过使用来回匹配来为查询过程找到更精确的匹配。
很多指令实现"><meta name="keywords" content="Blog"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Sweetyxz</a></h3><div class="description"><p>少就是多 慢就是快</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Sweetyxz"><i class="fa fa-github"></i></a></li><li><a href="mailto:2364539601@qq.com"><i class="fa fa-envelope"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Sweetyxz</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>【论文】firmup</a></h3></div><div class="post-content"><p><p>我们提出了一种新的二进制代码搜索技术，可以平衡查询过程和它所在的可执行文件之间的焦点。该方法基于稳健的底层语义过程相似性，并利用了我们的关键观察结果，即过程在其可执行文件的上下文中操作。</p>
<p>我们提出了一种算法，用来使用可执行文件中的周围过程，通过使用来回匹配来为查询过程找到更精确的匹配。</p>
<p>很多指令实现相同的功能，但由于指令选择、排序和寄存器使用方面的差异以及不同的代码和数据布局（偏移）的差异，发现这种相似性变得困难。</p>
<p>使用切片生成集中的计算过程，用一个编译器优化器，将我们称之为链的片段带到简洁的规范形式，同时也规范化寄存器名称和基地址偏移。将过程表示为一组链允许捕获语义相似性，因为有关如何执行计算的具体细节通过转换为链被抽象出来，这只反映了所计算的内容。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/DDDC22D433B64A7F8B6FE298428BB052?method=download&shareKey=49c735c84c1e90abf02136eb6603a5c6" alt="image"></p>
<ul>
<li>Both snippets retrieve a value from the stack (line 5 in (a), line 1 in (b)). 两个代码段都从堆栈中取出一个值</li>
<li>Both load the value 0x1F and use it in a jump comparison operation (lines 4 and 6 in (a), lines 5 and 6 in (b)). 两者都加载值 0x1F 并在跳转比较操作中使用它</li>
<li>Both snippets call a procedure (line 1 in (a), line 3 in (b)). 两个代码段都调用一个函数</li>
</ul>
<p>尽管在语义上并不等价，但这两个函数有很大的相似性，但是由于指令选择、顺序和寄存器使用的差异，以及不同的代码和数据布局(偏移量)，找到这种相似性非常困难。</p>
<p>我们将一对程序(q、t)的相似性定义为由这些程序共享的链的数量，并表示其Sim(q、t)</p>
<p>问题定义给定一个可执行文件F&#x3D;{T1，…，Tn}（例如，固件映像）和一个查询可执行文件Q，包含一个（脆弱的）过程qv，我们的目标是确定每个可执行文件Ti∈F是否包含与qv类似的过程。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/089AA291D1064C12BD5EE5E0DEF0A0D9?method=download&shareKey=4ecf680b5d3e008ce27be7f2c46edaad" alt="image"></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/BF4B6F91854640C38F82A7F872AFAFA9?method=download&shareKey=fa5f44aa8cadc136625681738ef7726b" alt="image"></p>
<p><strong>二次调研</strong></p>
<p>问题定义给定一个可执行文件F&#x3D;{T1，…，Tn}（例如，固件映像）和一个查询可执行文件Q，包含一个（脆弱的）过程qv，我们的目标是确定每个可执行文件Ti∈F是否包含与qv类似的过程。如果两个过程来自相同的源代码，我们将它们定义为类似的源代码。相似性可能会受到源代码（补丁、版本）的变化，并随着过程在语义上的不同而下降。F中的每个可执行文件都可以由任何编译器编译，也可以删除所有名称信息。</p>
<p><strong>捕获语义相似性</strong><br>为了允许我们的技术找到来自不同编译的二进制文件上的相似性，我们首先在BB级别上分解一个过程(一个BB是该过程的CFG中的一个节点)，并进一步在BB级别上应用切片[30]来生成聚焦的计算片段。然后，我们使用一个编译器优化器将我们称之为链的片段变为简洁的规范形式，同时也规范化寄存器名称和基地址偏移。将一组过程表示为一组链允许捕获语义相似性。我们将一对程序(q，t)的相似性定义为这些程序共享的链数，并将其表示为Sim(q，t)。</p>
<ol>
<li>固件二进制标示</li>
</ol>
<p><strong>二进制转换</strong></p>
<p>从位到IR表示(IR)：使用Angr.io框架[29]及其基于Valgrind的VEX表示[25]作为我们的lift工具链。Angr.io包含一个为Valgrind的VEX-IR的包装器。Angr.io提供了来自各种架构的lift，这使我们能够在整个固件爬行过程中最常见的架构上进行操作。VEX-IR（机器码转换过来的中间表达式）包含机器状态的完整表示。我们使用IDAPro[6]从可执行文件中解析和提取过程和BBs，因为我们注意到，当任务在可执行文件中查找所有过程和块时，它更准确</p>
<p><strong>转变嵌入式结构</strong>：处理四种不同的目标架构，MIPS32、ARM32、PPC32和Intel-x86，特别是来自真实固件映像的可执行文件，需要注意一些问题。</p>
<p>比如我们发现具ELFCLASS32头的MIPS64可执行文件（8字节对齐指令）在固件中是常见的。在MIPS可执行文件中，另一个需要注意的问题是使用了一个延迟分支插槽，这需要一个额外的指令来遵循任何分支指令。此附加指令将在解析分支目标时执行。这导致后续块的第一个指令被省略，并作为前一个块的一部分放置，从而导致链的差异。</p>
<p>最后，如前所述，二进制lift工具可能在某些过程中识别几个块，甚至完全省略整个过程。。我们在ELF文件的˙文本部分中添加了对CFG连接性和未占区域的覆盖率的检查。</p>
<ol start="2">
<li>程序分解<br>我们的过程的分解是基于CFG表示，其中我们最初在BB级别上分解每个过程。然后通过应用切片[30]，进一步将BBs分解为独立的执行单元,这将产生几个子块，每个子块只包含计算单个输出所需的指令(在BB中计算的面向外值的UseDef链)，子块就称之为链</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/43E1942DFC774C7AACFC268B4FD9B1A6?method=download&shareKey=ae1ac92ddeb01ebe11e6067e43cb1ec4" alt="image"></p>
<p>每个BB都被切片，直到所有的值都被覆盖为止。我们假设BB是单静态分配(SSA)的形式，这是我们使用的VEX-IR提升的一个特性。我们通过定义BB中所有指令（index）的集来初始化该过程。我们重复这个集合，在其中每一步中都选择迄今为止最后未发现的指令（top）。top被用作一条新链的基础。该链是通过向后迭代BB的指令，并仅在它定义了s使用的变量时添加每个指令来构建的。</p>
<p>在算法1中，我们使用RSet(i)作为指令i读取（或使用）的变量集，并使用WSet(i)作为它写入（或定义）的变量集。在任何情况下，一旦指令被任何链覆盖，它将（通过索引）从索引中删除。当我们分别处理每个BB时，一个块的输入是在在块中定义它们之前使用的变量（寄存器和内存位置）。</p>
<p><strong>规范化</strong></p>
<p>为了克服同一过程的不同汇编之间的语法差异，我们进一步将语义等价的链带到相同的语法形式。我们应用以下归一化和优化操作，使链成为一个简洁的规范形式：</p>
<ul>
<li>偏移消除: 走向规范形式的第一步是删除与二进制文件的具体结构相关的偏移值。对算法产生的链进行去除. 这包括跳转地址以及指向静态部分的地址。在可执行文件中。我们不删除与堆栈和结构操作相关的偏移量，因为它们与过程的语义更相关，可以作为过程处理的数据类型的描述符。</li>
<li>寄存器折叠：在写入之前读取的寄存器被转换为过程的参数，由链计算的最后一个值是返回值。我们注意到，即使过程的返回值存储在寄存器中，返回的值也必须首先在过程中生成，因此将在链中捕获</li>
<li>编译程序优化：接下来，我们对前一个偏移消除步骤中的每个链应用LLVM选项优化器。这是通过将VEX-IR链翻译为LLVM-IR来实现的。每条链都被翻译成一个LLVM-IR函数。使用成熟的现代优化器允许链转换为一个简洁和规范的形式，这是有用的寻找相似性。相关的优化包括表达式简化、持续折叠和传播、指令组合、通用子表达式消除和死码消除。</li>
<li>变量名称规范化：为了进一步推进链向正则形式的发展，我们根据它们出现的顺序重命名优化链中出现的变量。这项技术的灵感来自于以前的工作，旨在寻找在计算[15]上的等价性。这个最后阶段的输出是我们用于成对过程相似度度量的规范链。我们将Strands(p)表示为规范链的集合（每条链表示为其指令的一个字符串）。</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/37ED6868C9EE4A05BEF3C52EB5FDC4D3?method=download&shareKey=0afa10f1bfb839d8bd59ff6f14703ecc" alt="image"></p>
<p>提升链（在中间）逐字保留装配操作，并为每个值操作添加一个临时变量，寄存器名称和偏移也被保留。在优化和归一化名称和偏移量后，装配链（上）的整个操作简化为LLVM-IR规范链（底）的第一个指令，将归一化寄存器reg0(以前的s5)与折叠到v0寄存器中的0x1F常数进行比较。下面的说明反映分支操作，返回归一化偏移偏移0或pc中的下一个程序计数器值。<br>3. 两两过程相似性</p>
<p>在生成每个过程的链集后，我们计算成对的相似性。我们表示一个查询过程，即被搜索的过程，作为qv∈Q，其中Q是包含的查询可执行文件中所有过程的集合。</p>
<p>目标过程，即与候选过程q进行比较，用t∈T表示(类似地，T是包含的目标可执行文件)。给定一对(q，t)，我们将过程相似性定义如下：Sim(q，t)&#x3D;|Strands(q)∩Strands(t)|，即Sim(q，t)只是两种表示中共享的唯一规范链的数量。</p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: Sweetyxz</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/tags/论文/" title="论文">论文 </a><span class="leancloud_visitors"></span><span>About 2774 words, 9 min 14 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2021/07/05/firmup/,Sweetyxz,【论文】firmup,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/07/15/charm/" title="【论文】Charm-Facilitating dynamic analysis of device drivers of mobile systems.">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/06/23/Python/" title="【Python】Python基础知识">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>