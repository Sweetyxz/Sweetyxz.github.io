{"pages":[],"posts":[{"title":"【Python】Python基础知识","text":"变量和简单数据类型变量 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头 变量名不能包含空格，但可使用下划线来分隔其中的单词。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词， 变量名应既简短又具有描述性。例如，name比n好 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。 字符串 方法title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写 将字符串改为全部大写upper()或全部小写lower() 要在字符串中插入变量的值，可在前引号前加上字母f””，再将要插入的变量放在花括号内。这样，当Python显示字符串时，将把每个变量都替换为其值. 12name = &quot;Lily&quot;sen = f&quot;Hello {name}, I like Python very much&quot; 这种字符串名为f字符串。f是format（设置格式）的简写，因为Python通过把花括号内的变量替换为其值来设置字符串的格式 要在字符串中添加制表符，可使用字符组合\\t 要在字符串中添加换行符，可使用字符组合\\n 要确保字符串末尾没有空白，可使用方法rstrip(),你还可以剔除字符串开头的空白，或者同时剔除字符串两边的空白。为此，可分别使用方法lstrip()和strip() 数 Python使用两个乘号表示乘方运算 Python将所有带小数点的数称为浮点数 将任意两个数相除时，结果总是浮点数，即便这两个数都是整数且能整除： 无论是哪种运算，只要有操作数是浮点数，Python默认得到的总是浮点数，即便结果原本为整数也是如此 书写很大的数时，可使用下划线将其中的数字分组，使其更清晰易读 12a = 14_0000_0000print(a) -&gt; 1400000000 当你打印这种使用下划线定义的数时，Python不会打印其中的下划线 Python没有内置的常量类型，但Python程序员会使用全大写来指出应将某个变量视为常量，其值应始终不变12FAVORITE_NUM = 10print(&quot;最喜欢的数是：&quot; + str(FAVORITE_NUM)) 列表 列表由一系列按特定顺序排列的元素组成。在Python中，用方括号（[]）表示列表，并用逗号分隔其中的元素。 Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返回最后一个列表元素。这种约定也适用于其他负数索引。例如，索引-2返回倒数第二个列表元素，索引-3返回倒数第三个列表元素，依此类推 方法append()将元素添加到列表末尾 使用方法insert()可在列表的任何位置添加新元素 1insert(index, value) 如果知道要删除的元素在列表中的位置，可使用del语句。使用del可删除任意位置处的列表元素，条件是知道其索引 123# deldel names[1]print(names) 方法pop()删除列表末尾的元素，并让你能够接着使用它。术语弹出（pop）源自这样的类比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。实际上，可以使用pop()来删除列表中任意位置的元素，只需在圆括号中指定要删除元素的索引即可 12345678#pop()last_name = names.pop()print(last_name)print(names)# pop(index)second_name = names.pop(1)print(second_name)print(names) 如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()。 方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除 123#remove()names.remove('snn')print(names) Python方法sort()让你能够较为轻松地对列表进行排序。方法sort()永久性地修改列表元素的排列顺序。还可以按与字母顺序相反的顺序排列列表元素，只需向sort()方法传递参数reverse=True即可。 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]cars.sort()cars.sort(reverse = True) 要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()。如果要按与字母顺序相反的顺序显示列表，也可向函数sorted()传递参数reverse=True。 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]print(sorted(cars))print(sorted(cars, reverse = True)) 要反转列表元素的排列顺序，可使用方法reverse()。方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调用reverse()即可 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]cars.reverse()print(cars) 使用函数len()可快速获悉列表的长度 每当需要访问最后一个列表元素时，都可使用索引-1。仅当列表为空时，这种访问最后一个元素的方式才会导致错误 操作列表 Python根据缩进来判断代码行与前一个代码行的关系。 for语句末尾的冒号告诉Python，下一行是循环的第一行 Python函数range()让你能够轻松地生成一系列数。例如，可以像下面这样使用函数range()来打印一系列数。函数range()让Python从指定的第一个值开始数，并在到达你指定的第二个值时停止。 12nums = list(range(0,10))print(nums) 使用函数range()时，还可指定步长 12numss = list(range(0, 10, 2))print(numss) ==列表解析==将for循环和创建新元素的代码合并成一行，并自动附加新元素，请注意，这里的for语句末尾没有冒号 12squ = [value ** 2 for value in range(0, 3)]print(squ) 处理列表的部分元素，Python称之为==切片==，要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range()一样，Python在到达第二个索引之前的元素后停止。如果没有指定第一个索引，Python将自动从列表开头开始。 12345names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]print(names[0:3])print(names[:3])print(names[2:])print(names[-3:]) 可在表示切片的方括号内指定第三个值。这个值告诉Python在指定范围内每隔多少元素提取一个。 12names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]print(names[0:4:3]) 要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]） 12345names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]other_names = names[:] #复制列表使用切片 而非赋值other_names.append(&quot;lmy&quot;)print(other_names)print(names) ==使用赋值语句实际上是将两个变量指向同一个列表== Python将不能修改的值称为不可变的，而不可变的列表被称为==元组==，元组看起来很像列表，但使用圆括号而非中括号来标识。 123turp = (1,3)print(turp[0])print(turp[1]) 严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含一个元素的元组，必须在这个元素后面加上逗号。 12turp = (1,)print(turp[0]) 虽然不能修改元组的元素，但可以给存储元组的变量赋值 1234567turp = (1,3)print(turp[0])print(turp[1])turp = (2,5)print(turp[0])print(turp[1]) 如果需要存储的一组值在程序的整个生命周期内都不变，就可以使用元组 if语句 每条if语句的核心都是一个值为True或False的表达式，这种表达式称为==条件测试== 在Python中检查是否相等时区分大小写。 有时候需要在两个条件都为True时才执行相应的操作，而有时候只要求一个条件为True。在这些情况下，关键字and和or可助你一臂之力 要判断特定的值是否已包含在列表中，可使用关键字in。 还有些时候，确定特定的值未包含在列表中很重要。在这种情况下，可使用关键字not in。 Python只执行if-elif-else结构中的一个代码块 else是一条包罗万象的语句，只要不满足任何if或elif中的条件测试，其中的代码就会执行。这可能引入无效甚至恶意的数据。如果知道最终要测试的条件，应考虑使用一个elif代码块来代替else代码块 在运行for循环前确定列表是否为空很重要 在if语句中将列表名用作条件表达式时，Python将在列表至少包含一个元素时返回True，并在列表为空时返回False。 12345num = []if num: print(&quot;yes&quot;)else: print(&quot;no&quot;) 字典 在Python中，字典是一系列==键值对==。每个键都与一个值相关联，你可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。 在Python中，字典用放在花括号（{}）中的一系列键值对表示，键和值之间用冒号分隔，而键值对之间用逗号分隔 12name_age = {'zyx': 22, 'lmy': 23}print(name_age) 要获取与键相关联的值，可依次指定字典名和放在方括号内的键12name_age = {'zyx': 22, 'lmy': 23}print(name_age['zyx']) 字典是一种动态结构，可随时在其中添加键值对,要添加键值对，可依次指定字典名、用方括号括起的键和相关联的值 1234name_age = {'zyx': 22, 'lmy': 23}print(name_age)name_age['snn'] = 23 #新增键值对name_age['xxf'] = 23 对于字典中不再需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键.==删除的键值对会永远消失==。 123name_age = {'zyx': 22, 'lmy': 23}del name_age['lmy']print(name_age) 使用放在方括号内的键从字典中获取值时，可能会引发问题：如果指定的键不存在就会出错。方法get()的第一个参数用于指定键，是必不可少的；第二个参数为指定的键不存在时要返回的值，是可选的. 123name_age = {'zyx': 22, 'lmy': 23}other_name = name_age.get('nn', 'no such name') #get 方法print(other_name) 如果指定的键有可能不存在，应考虑使用方法get()，而不要使用方括号表示法7. for语句的第二部分包含字典名和方法items()，它返回一个键值对列表; 在不需要使用字典中的值时，方法keys()很有用。方法keys()并非只能用于遍历：实际上，它返回一个列表，其中包含字典中的所有键. 在只需要值时，使用方法values() 可使用函数sorted()来获得按特定顺序排列的键列表的副本. 最终的列表可能包含大量重复项。为剔除重复项，可使用集合（set）。集合中的每个元素都必须是独一无二的： 123456789101112my = {&quot;firstname&quot;: 'z', 'lastname': 'yx', &quot;age&quot;: 22, 'city': 'hangzhou', &quot;num&quot;: 22}for key,value in my.items():# 遍历键值对 print(f&quot;key is {key}&quot;) print(f&quot;value is {value}&quot;)for k in my.keys(): #只输出键 print(f&quot;key is {k}&quot;)for k in sorted(my.keys()): #排序后的键 print(f&quot;key is {k}&quot;)for v in my.values(): #只输出键 print(f&quot;value is {v}&quot;)for v in set(my.values()): #只输出键 print(f&quot;value is {v}&quot;) 可使用一对花括号直接创建集合，并在其中用逗号分隔元素（不含重复元素，集合） 12my = {1, 2, 3, 2} #集合print(my) 有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为==嵌套== 用户输入和while循环 函数input()接受一个参数——要向用户显示的提示（prompt）或说明，让用户知道该如何做。 12mes = input(&quot;输入姓名&quot;)print(mes) 使用函数input()时，Python将用户输入解读为字符串。将==数值输入用于计算和比较前，务必将其转换为数值==表示 求模运算符（%）是个很有用的工具，它将两个数相除并返回余数 12345num = input(&quot;input num: &quot;)if int(num) % 10 == 0: print(&quot;yes&quot;)else: print(&quot;no&quot;) 在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量称为==标志（flag）==，充当程序的交通信号灯 要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句 要返回循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环 for循环是一种遍历列表的有效方式，但不应在for循环中修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环","link":"/2021/06/23/Python/"},{"title":"【Go】Go基础知识","text":"Go的优势 可以直接编译成机器码 不依赖其他库 可以直接部署 静态类型语言 天生支持并发 充分利用多核 强大的标准库： runtime系统调度机制，高效的GC垃圾回收 丰富的标准库 Go的基础知识 定义变量：12var name typevar i int = 1 也可以让语言自行判定： 1var i = 1 或者： 1i := 1 这种只能在函数体内出现声明多变量： 1234567var( //一般用于声明全局变量 a int b string)var a, b = 1, '123' ==字符串用双引号==2. 常量定义 1const identifier [type] = value iota特殊常量 在同一个常量组中，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引) 12345const( a = iota //0 b //1 c //2) 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。如： 123456const ( a = 1 b //1 c //1 d //1) go中没有while循环 函数定义 1234567func function_name( [parameter list(type)] ) ([return_types]) { 函数体}func add(num1 string, num2 int) (string, int) { return num1, num2} ==闭包== Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。 12345678func getSequence() func() int { i:=0 return func() int { i+=1 return i }} 数组 声明数组 123var variable_name [SIZE] variable_typevar balance [10] float32 初始化数组 123456var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}数组长度不确定时var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}或balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 指针的定义 1234var var_name *var-typevar ip *int /* 指向整型*/var fp *float32 /* 指向浮点型 */ 指针数组 1var ptr [5]*int; 指向指针的指针 1var ptr **int 8.","link":"/2021/08/09/go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"【linux】linux常用命令","text":"chmod 更改文件权限 处理目录 1234567891011121314151617ls（英文全拼：list files）: 列出目录及文件名cd（英文全拼：change directory）：切换目录pwd（英文全拼：print workdirectory）：显示目前的目录mkdir（英文全拼：make directory）：创建一个新的目录rmdir（英文全拼：remove directory）：删除一个空的目录cp（英文全拼：copy file）: 复制文件或目录rm（英文全拼：remove）: 删除文件或目录mv（英文全拼：move file）:移动文件与目录，或修改文件与目录的名称 文件查看 1234567cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行 查看linux版本123查看操作系统版本信息 cat /proc/versionuname -auname -m 显示32位或64位 运行 Shell 脚本有两种方法： 作为可执行程序 12345将上面的代码保存为 test.sh，并 cd 到相应目录：chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 作为解释器参数 1234这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：/bin/sh test.sh/bin/php test.php","link":"/2021/06/02/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"【Python】乱起八糟的Python知识点","text":"Python内置的==enumerate==函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身 123456 for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C 可迭代对象可以直接作用于for循环的对象统称为可迭代对象：==Iterable==123456listtupledictsetstrgenerator 以及带yield的generator function 可使用isinstance()判断是否为可迭代对象 1234567891011&gt;&gt;&gt; from collections.abc import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 迭代器可以被next()函数调用并不断返回下一个值的对象称为迭代器：==Iterator==可以使用isinstance()判断一个对象是否是Iterator对象 123456789&gt;&gt;&gt; from collections.abc import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象4. reduce用法reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 123456from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 利用filter()求素数 12345678910111213141516171819202122232425def check_su(): n = 1 while True: n += 2 yield ndef fliter_fun(n): return lambda x: x % n &gt; 0def main(): yield 2 i = check_su() while True: n = next(i) yield n i = filter(fliter_fun(n), i)for n in main(): if n &lt; 100: print(n) else: break 装饰器 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 123456789101112131415161718192021def text_input(text): def log(func): @functools.wraps(func) def wrapper(*args, **kw): print(f&quot;call {func.__name__} {text}&quot;) return func(*args, **kw) return wrapper return log@text_input('8.15')def now(): print('2021')now()print(now.__name__)---call now 8.152021now 其中去掉@functools.wraps(func)，now.name会变成wrapper 动态绑定 动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现 1234567891011class student: passs = student()s.name = 'zyx' # 动态绑定新的属性def show_name(self, name): print(name)s.show_name = MethodType(show_name, s) # 给实例动态绑定方法 from types import MethodTypestudent.show_name = show_name # 动态绑定新的函数 slots 要限制实例的属性，比如只允许对Student实例添加name和age属性，可以定义一个特殊的__slots__变量，来限制该class实例能添加的属性 1234567class student: __slots__ = (name, age)s = student()s.name = 'zyx's.age = '22's.score = 5 # 报错 ==使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的== 9.@property 10.zip()函数","link":"/2021/08/17/%E4%B9%B1%E8%B5%B7%E5%85%AB%E7%B3%9F%E7%9A%84python%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"【Python】流畅的Python读书笔记","text":"切片的表达式 1object[start_index:end_index:step] step：正负数均可，其绝对值大小决定了切取数据时的‘‘步长”，而正负号决定了“切取方向”，正表示“从左往右”取值，负表示“从右往左”取值。当step省略时，默认为1，即从左往右以步长1取值。 sorted函数如果要按照某个规则排序，则需指定参数 key， key 是一个函数对象 例如字符串构成的列表，我想按照字符串的长度来排序 123chars = ['Andrew', 'This', 'a', 'from', 'is', 'string', 'test']print(sorted(chars, key=len)) 匿名函数 不需要显示的指定函数名 123calc = lambda n: n**nlambda表示匿名函数n表示函数参数 比如 123456789101112131415161718#这段代码def calc(x,y): return x**y#换成匿名函数calc = lambda x,y:x**yprint(calc(2,5))#三元运算def calc(x,y): if x &gt; y: return x*y else: return x / y #三元运算换成匿名函数calc = lambda x,y:x * y if x &gt; y else x / yprint(calc(2,5)) map()函数 map() 会根据提供的函数对指定序列做映射。 1map(function, iterable, ...) 第一个参数 function 以参数序列中的每一个元素调用 function 函数 123456789def square(x) : # 计算平方数... return x ** 2...&gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方&lt;map object at 0x100d3d550&gt; # 返回迭代器&gt;&gt;&gt; list(map(square, [1,2,3,4,5])) # 使用 list() 转换为列表[1, 4, 9, 16, 25]&gt;&gt;&gt; list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) # 使用 lambda 匿名函数[1, 4, 9, 16, 25] filter()函数 filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器对象。 1filter(function, iterable) 比如 123456def is_odd(n): return n % 2 == 1 tmplist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])newlist = list(tmplist)print(newlist) 迭代器与生成器 12345678910def test(): yield 1 a = 1 + 1 yield a yield 3res = test()print(next(res)) # 1print(next(res)) # 2print(res.__next__()) #3","link":"/2021/08/13/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"title":"【论文】符号执行与符号虚拟机","text":"KLEE是一个建立在LLVM编译框架上的符号执行工具，它可以自动生成复杂和环境密集型程序的高覆盖率的测试用例。 传统的符号执行，动态符号执行，可选择的符号执行 传统的符号执行是一种静态的符号执行。它仅基于解析程序；输入变量被表示为模拟执行，而不是程序的实际执行。动态符号执行是符号执行和具体执行的结合，继承了两者的优点。研究人员可以执行选择性的符号执行，以在程序的某些区域上执行符号执行，其余的则执行特定的执行 基本原理 符号执行技术的基本原理是符号化程序的输入数据，即使用符号变量而不是实值来探索和解析程序。为了表示可能的执行流程，可以绘制程序的控制流程图(CFG)，以方便分析在执行过程中遍历的所有路径。此外，还可以创建一个引用到CFG的符号执行树，以记录与每个路径生成的程序输入变量关联的符号表达式 动态符号执行通过特定的输入来执行该程序。在收集约束的过程中，对输入变量进行顺序符号化，然后使用约束求解器来判断输入的变化，然后确定程序的下一个执行路径。除此之外，在程序的分支处，根据某些规则反转约束，并获得一个新的约束集。然后重复这种方法，尽可能多地遍历所有路径，以获得更高的覆盖率，值得一提的是，路径约束是通过每个分支约束的逻辑操作得到的一系列布尔表达式 KLEE KLEE是一个符号执行工具，用于检测程序漏洞，自动生成测试用例，实现高测试覆盖率。KLEE基于EXE[7]，其主要目标语言是C语言。 基本结构 KLEE在LLVM编译框架的情况下执行符号执行。生成一个执行测试主要涉及变量符号化、路径搜索和约束求解。变量通常通过在执行测试时调用程序中的klee_make_symbolic函数来表示。KLEE的解释组件执行代码的符号语义，并根据计算结果更新内存模型中的符号状态。内存模型组件跟踪符号状态，定义内存操作的语义，并处理特定的约束公式，以方便KLEE的决策和收集约束 执行完成后，编译器将源程序编译为LLVM[10]的中间语言。该语言有三个可互换的表达式：一个是LLVM字节码(.bc文件)，它是一种存储在硬盘上的二进制文件，可以通过KLEE命令直接执行。另一种是可读的中间格式(.ll文件)，具有较高的可读性，可以全面反映编译器内部数据的处理和传输。最后一种是内存中编译的中间语言 KLEE的约束解决 KLEE使用的约束求解器是STP。该过程主要是解决收集到的约束集，并以此来选择执行路径，解决变量值。首先，约束求解模块通过相关算法简化了约束集。例如，现有的条件(x&gt;5，x=6)可以简化为(x&gt;5)。然后，由于KLEE将约束描述为KQuery(KQuery语言是KLEE约束表达式的文本表示语言，其语法在执行过程[11]中由扩展的Bacchus范式表示)，因此将约束集转移到约束求解模块，并调用求解器的函数接口进行解析和转换约束。只有在将约束转换为求解器的语法描述格式后，才能启动求解过程。当上述步骤完成后，求解器通过一系列简化和转换的约束集表达式来求解结果","link":"/2021/08/04/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%AC%A6%E5%8F%B7%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"【论文】firmup","text":"我们提出了一种新的二进制代码搜索技术，可以平衡查询过程和它所在的可执行文件之间的焦点。该方法基于稳健的底层语义过程相似性，并利用了我们的关键观察结果，即过程在其可执行文件的上下文中操作。 我们提出了一种算法，用来使用可执行文件中的周围过程，通过使用来回匹配来为查询过程找到更精确的匹配。 很多指令实现相同的功能，但由于指令选择、排序和寄存器使用方面的差异以及不同的代码和数据布局（偏移）的差异，发现这种相似性变得困难。 使用切片生成集中的计算过程，用一个编译器优化器，将我们称之为链的片段带到简洁的规范形式，同时也规范化寄存器名称和基地址偏移。将过程表示为一组链允许捕获语义相似性，因为有关如何执行计算的具体细节通过转换为链被抽象出来，这只反映了所计算的内容。 Both snippets retrieve a value from the stack (line 5 in (a), line 1 in (b)). 两个代码段都从堆栈中取出一个值 Both load the value 0x1F and use it in a jump comparison operation (lines 4 and 6 in (a), lines 5 and 6 in (b)). 两者都加载值 0x1F 并在跳转比较操作中使用它 Both snippets call a procedure (line 1 in (a), line 3 in (b)). 两个代码段都调用一个函数 尽管在语义上并不等价，但这两个函数有很大的相似性，但是由于指令选择、顺序和寄存器使用的差异，以及不同的代码和数据布局(偏移量)，找到这种相似性非常困难。 我们将一对程序(q、t)的相似性定义为由这些程序共享的链的数量，并表示其Sim(q、t) 问题定义给定一个可执行文件F={T1，…，Tn}（例如，固件映像）和一个查询可执行文件Q，包含一个（脆弱的）过程qv，我们的目标是确定每个可执行文件Ti∈F是否包含与qv类似的过程。 二次调研 问题定义给定一个可执行文件F={T1，…，Tn}（例如，固件映像）和一个查询可执行文件Q，包含一个（脆弱的）过程qv，我们的目标是确定每个可执行文件Ti∈F是否包含与qv类似的过程。如果两个过程来自相同的源代码，我们将它们定义为类似的源代码。相似性可能会受到源代码（补丁、版本）的变化，并随着过程在语义上的不同而下降。F中的每个可执行文件都可以由任何编译器编译，也可以删除所有名称信息。 捕获语义相似性为了允许我们的技术找到来自不同编译的二进制文件上的相似性，我们首先在BB级别上分解一个过程(一个BB是该过程的CFG中的一个节点)，并进一步在BB级别上应用切片[30]来生成聚焦的计算片段。然后，我们使用一个编译器优化器将我们称之为链的片段变为简洁的规范形式，同时也规范化寄存器名称和基地址偏移。将一组过程表示为一组链允许捕获语义相似性。我们将一对程序(q，t)的相似性定义为这些程序共享的链数，并将其表示为Sim(q，t)。 固件二进制标示 二进制转换 从位到IR表示(IR)：使用Angr.io框架[29]及其基于Valgrind的VEX表示[25]作为我们的lift工具链。Angr.io包含一个为Valgrind的VEX-IR的包装器。Angr.io提供了来自各种架构的lift，这使我们能够在整个固件爬行过程中最常见的架构上进行操作。VEX-IR（机器码转换过来的中间表达式）包含机器状态的完整表示。我们使用IDAPro[6]从可执行文件中解析和提取过程和BBs，因为我们注意到，当任务在可执行文件中查找所有过程和块时，它更准确 转变嵌入式结构：处理四种不同的目标架构，MIPS32、ARM32、PPC32和Intel-x86，特别是来自真实固件映像的可执行文件，需要注意一些问题。 比如我们发现具ELFCLASS32头的MIPS64可执行文件（8字节对齐指令）在固件中是常见的。在MIPS可执行文件中，另一个需要注意的问题是使用了一个延迟分支插槽，这需要一个额外的指令来遵循任何分支指令。此附加指令将在解析分支目标时执行。这导致后续块的第一个指令被省略，并作为前一个块的一部分放置，从而导致链的差异。 最后，如前所述，二进制lift工具可能在某些过程中识别几个块，甚至完全省略整个过程。。我们在ELF文件的˙文本部分中添加了对CFG连接性和未占区域的覆盖率的检查。 程序分解我们的过程的分解是基于CFG表示，其中我们最初在BB级别上分解每个过程。然后通过应用切片[30]，进一步将BBs分解为独立的执行单元,这将产生几个子块，每个子块只包含计算单个输出所需的指令(在BB中计算的面向外值的UseDef链)，子块就称之为链 每个BB都被切片，直到所有的值都被覆盖为止。我们假设BB是单静态分配(SSA)的形式，这是我们使用的VEX-IR提升的一个特性。我们通过定义BB中所有指令（index）的集来初始化该过程。我们重复这个集合，在其中每一步中都选择迄今为止最后未发现的指令（top）。top被用作一条新链的基础。该链是通过向后迭代BB的指令，并仅在它定义了s使用的变量时添加每个指令来构建的。 在算法1中，我们使用RSet(i)作为指令i读取（或使用）的变量集，并使用WSet(i)作为它写入（或定义）的变量集。在任何情况下，一旦指令被任何链覆盖，它将（通过索引）从索引中删除。当我们分别处理每个BB时，一个块的输入是在在块中定义它们之前使用的变量（寄存器和内存位置）。 规范化 为了克服同一过程的不同汇编之间的语法差异，我们进一步将语义等价的链带到相同的语法形式。我们应用以下归一化和优化操作，使链成为一个简洁的规范形式： 偏移消除: 走向规范形式的第一步是删除与二进制文件的具体结构相关的偏移值。对算法产生的链进行去除. 这包括跳转地址以及指向静态部分的地址。在可执行文件中。我们不删除与堆栈和结构操作相关的偏移量，因为它们与过程的语义更相关，可以作为过程处理的数据类型的描述符。 寄存器折叠：在写入之前读取的寄存器被转换为过程的参数，由链计算的最后一个值是返回值。我们注意到，即使过程的返回值存储在寄存器中，返回的值也必须首先在过程中生成，因此将在链中捕获 编译程序优化：接下来，我们对前一个偏移消除步骤中的每个链应用LLVM选项优化器。这是通过将VEX-IR链翻译为LLVM-IR来实现的。每条链都被翻译成一个LLVM-IR函数。使用成熟的现代优化器允许链转换为一个简洁和规范的形式，这是有用的寻找相似性。相关的优化包括表达式简化、持续折叠和传播、指令组合、通用子表达式消除和死码消除。 变量名称规范化：为了进一步推进链向正则形式的发展，我们根据它们出现的顺序重命名优化链中出现的变量。这项技术的灵感来自于以前的工作，旨在寻找在计算[15]上的等价性。这个最后阶段的输出是我们用于成对过程相似度度量的规范链。我们将Strands(p)表示为规范链的集合（每条链表示为其指令的一个字符串）。 提升链（在中间）逐字保留装配操作，并为每个值操作添加一个临时变量，寄存器名称和偏移也被保留。在优化和归一化名称和偏移量后，装配链（上）的整个操作简化为LLVM-IR规范链（底）的第一个指令，将归一化寄存器reg0(以前的s5)与折叠到v0寄存器中的0x1F常数进行比较。下面的说明反映分支操作，返回归一化偏移偏移0或pc中的下一个程序计数器值。3. 两两过程相似性 在生成每个过程的链集后，我们计算成对的相似性。我们表示一个查询过程，即被搜索的过程，作为qv∈Q，其中Q是包含的查询可执行文件中所有过程的集合。 目标过程，即与候选过程q进行比较，用t∈T表示(类似地，T是包含的目标可执行文件)。给定一对(q，t)，我们将过程相似性定义如下：Sim(q，t)=|Strands(q)∩Strands(t)|，即Sim(q，t)只是两种表示中共享的唯一规范链的数量。","link":"/2021/07/05/firmup/"},{"title":"【论文】inception：一个执行完整的真实世界的嵌入式固件的安全测试的框架","text":"inception：一个执行完整的真实世界的嵌入式固件的安全测试的框架目标：利用高级源代码的语义信息来检测符号执行过程中的漏洞，同时也支持低级汇编代码和与硬件外设的频繁交互。 做了啥：Incption转换器从高级源代码、手写汇编、二进制库和部分处理器硬件行为中生成和合并LLVM位码。这种设计减少了与实际执行和手动工作之间的差异。保留了源代码语义，提高了安全检查的有效性。基于KLEE的初始符号虚拟机执行符号执行，使用几种策略来处理不同级别的内存抽象、与外设的交互和中断。最后，I调试器是Inception一个高性能的JTAG调试器，它执行对真实硬件的内存访问的重定向。 常见的符号执行环境通常运行与架构无关的代码，可以从源代码中导出，而不会丢失语义信息。或者，依赖架构的二进制代码可以提升到中间表示，至少可以部分执行到符号虚拟机，但丢失了源代码语义信息。这两种情况差异很大（例如，在它们的记忆模型中），并且不能很容易地共存。 inception由三部分组成。 首先，初始转换器，它使用lift和合并过程生成统一的LLVM-IR，将程序的组装和二进制部分集成到来自高级源的中间表示中。这个过程还考虑到了ARMv7-M体系结构的低级硬件机制。 其次，inception符号虚拟机，它能够执行这个混合级别的LLVM-IR，并处理具有不同策略的中断和内存映射外设，以适应不同的用例。它还可以根据需求生成中断，并从外围设备内存作为不受约束的符号值读取。这个虚拟机基于KLEE，这是一个著名的开源符号执行的、运行LLVM-IR位码的符号执行虚拟机。 inception调试器，这是一个自定义的快速调试器，围绕一个USB3总线适配器和一个FPGA构建。它提供了对外围设备的高速访问，并可以很容易地扩展到多个目标。 lift和合并过程图显示了我们的位码合并方法的主要阶段，以及如何将具有内联程序集1的源代码转换为一致的可以由初始VM执行的位码3。示例代码包含程序集中编写的函数的节录，该函数请求r0包含数据字节的系统调用。 代码的其余部分由调用第一个汇编函数的主函数和要发送的消息组成。使用适当的LLVM前端（CLang为C/C++），源代码1将转换为LLVM-IR位码。结果的位码2显示只有C/C++源代码已经真正被翻译成了LLVM-IR。实际上，LLVM-IR位码的最初目的是在代码降低到目标体系结构之前实现高级优化，而程序集已经处于低语义级别，无法由LLVM编译器表示或优化 为了解决这个问题，我们引入了一种新的生命和合并方法，我们在感知转换器中实现了它。该转换器以CLang生成的ELF二进制文件和LLVM-IR位码作为输入。它生成一个一致的LLVM-IR位码，其中汇编指令已被抽象到一个LLVM-IR表单。此步骤由静态升降机（static lifter）完成，它用一系列LLVM-IR指令替换每个装配指令。我们将所得到的位码称为混合语义级位码(混合IR)，如3所示，其中包含： 从C/C++源代码中获得的高语义级IR（高IR）。这主要是CLang发出的代码，该代码由程序集源文件中定义的外部全局变量扩展。我们在IR中重新分配了这些全局变量。 从程序集源代码衍生出的低语义级IR（低IR）。这部分是由我们的静态升降机自动生成的。它包含了汇编指令的转换和执行所必需的一些与体系结构相关的元素。首先，将CPU和协处理器的寄存器建模为全局变量。其次，特定的功能可以模拟了通常由CPU处理的无缝硬件机制。例如，当输入中断服务例程(ISR)时，处理器会透明地更新堆栈指针，并堆叠CPU寄存器的一个子集。当ISR返回时，上下文将自动恢复，这样，被中断挂起的代码就可以恢复了。 Glue IR，可以在高级语义和低级语义域之间进行切换。此IR位码由特定的应用程序二进制接口(ABI)适配器生成，能够提升或降级抽象级别。实际上，层之间的通信和切换主要发生在函数之间的接口上，即当高级函数调用低级函数或相反函数时。 inception符号虚拟机 由lift和合并过程产生的位码几乎是可执行的，但它仍然需要虚拟机中的一些额外的支持。主要的挑战是highIR只访问类型的变量，而不建模内存地址或指针。另一方面，从汇编指令生成的IR已经丢失了有关类型和变量的所有信息，并且只访问指针和非类型数据。另一个挑战是处理由代码使用但未分配的内存映射内存，以及不在KLEE中建模的中断和上下文开关 为了解决这些问题，我们使用内存管理器和中断管理器扩展了KLEE。在（符号）执行过程中，KLEE的原始内存监视器会对内存访问执行高级安全检查。当检测到违规时，约束求解器将生成一个可重播的测试用例 内存管理器利用ELF二进制文件和混合IR文件来构建一个统一的内存布局，其中两个语义域都可以访问内存。分配特定的数据区域以运行低IR代码，比如代码部分和一些内存部分（堆栈、堆栈、BSS）中包含的指针。每个内存地址都可配置以模拟正常固件的环境。例如，一个内存映射的位置可以被重定向到真实的外围设备，以修剪符号探索和使用真实的值。或者，它可以在虚拟机上分配，并标记为符号来模拟来自不受信任的外设的输入。初始空间还支持直接内存访问(DMA)外设，前提是每个DMA缓冲区都被标记为重定向到真正的设备内存。与其他重定向位置类似，DMA缓冲区不能保留符号值。 中断管理器通过中断执行和调用相应的中断处理程序，赋予KLEE处理中断事件的能力。使用中断向量表解决中断的地址。中断事件可以在实际硬件上收集，或者由用户在需要时生成（通过调用特殊的处理程序函数）。在第一种情况下，虚拟机和真实设备被正确地同步，以避免任何不一致。我们进一步扩展了KLEE来执行在多线程应用程序中的线程之间切换上下文的处理程序。 内存监视器和安全检查。所有的安全分析都主要依赖于KLEE的内存监视器，它能够基于与每次访问相关的语义信息对每次访问进行安全检查。监视器观察请求的语义信息（请求类型）和访问数据（访问类型）的语义信息。当有足够的信息可用时，监视器能够检测内存访问违规，例如，边界外访问、无后使用或返回后使用。来自高红外的请求和访问用高红外定义的内存元素，有足够的信息来检测大多数违规行为。相反，来自低红外的请求往往信息较少，检测率也较低。然而，由于来自高红外值的信息，仍然有可能检测到比仅使用二进制文件更多的问题。 实验和验证 lift和合并过程 为了能够将组件和二进制文件与源代码粘合成一个统一的LLVM-IR表示形式(混合-IR)，我们应用了两个不同的过程。 lift过程采用机器代码（编译汇编或二进制文件）并生成等效的中间表示（低IR）。这种表示只使用了LLVM-IR语言的低级特性，它模拟了原始架构(ARMv7-M)，其中包含了Cortex-M3处理器的一些硬件语义，比如带有副作用的指令的行为。因此，它（几乎）是自包含的，其中很大一部分可以在任何能够解释LLVM-IR的虚拟机上执行。正如以下几部分所解释的，我们向KLEE介绍了一些特性，以使这段代码完全可执行，特别是在处理上下文切换时。 我们的升降机是基于三个主要的零部件组成的。 首先，一个静态递归反汇编程序，它找到所有的指令并将其存储为内部图表示。 其次，一个简单的反编译器，包括间接分支和复杂的硬件机制（例如，从中断和上下文开关返回）。 最后，升降机静态地将给定的机器指令转换为语义上等效的LLVMIR指令序列。静态方法的一个重要优点是，它使源进一步处理源产生混合IR。此外，与在执行过程中提升指令的动态提升器相比，它具有较低的运行时开销。 合并过程采用（几乎）自含的低IR和由C/C++编译的高IR，将它们粘在一起（用一些Glue IR）。这是最具挑战性的部分，因为它们有不同层次的语义信息和不同层次的记忆视图。 因此，第一步是在KLEE虚拟机中的两个IR级别之间创建一个统一的内存布局。除此之外，外围设备地址还可以在KLEE中访问这些地址。第二步包括确定这两种表示法之间的最佳接口和在这个边界上交换数据的机制。我们选择使用应用程序二进制接口(ABI)，它以统一的方式调节函数之间的通信。我们的合并能够生成粘合IR代码，使高IR函数与低IR函数通信，反之亦然。 统一的内存布局 如何利用lift和合并过程和KLEE来创建统一的内存布局。这种内存布局是低IR和高IR共存和通信的核心。 处理器寄存器 由于不同的原因，处理器寄存器由全局变量表示。首先，LLVM-IR是一种单一静态分配(SSA)语言，其中每条指令都将其结果存储在一个唯一分配的寄存器中。其次，LLVM支持无限数量的寄存器，这些寄存器只分配一次，不能全局访问。因此，LLVM寄存器不能用于表示CPU寄存器，这些寄存器受到限制、分配多次，并通过指令全局访问。 堆当高IR代码运行时，会使用正常的KLEE堆栈。每个函数都有自己的函数框架对象，该对象包含有关执行的元数据。这包括关于调用者、SSA寄存器值（包含临时本地变量）和本地变量（使用正常KLEE机制分配）的信息。低IR代码使用了一个单独的堆栈。此堆栈被建模为一个全局整数数组，由内存管理器以与符号表的stack部分相同的地址和大小分配。 数据区域包含混合的语义级变量。实际上，当高IR分配数据时，生成的内存对象被键入并在符号表所指示的相同地址进行分配，以保持与组件代码的兼容性。另一方面，数据可以由汇编代码定义，并通过高IR访问。在这种情况下，我们使用高IR的外部声明中存在的语义信息来分配一个类型化的对象。第三种可能的情况是由程序集代码分配的数据，但从未被高级代码访问。在这种情况下，不存在语义信息，分配取决于ELF符号表中的信息。 应用程序二进制接口适配器 低IR函数遵循标准的臂应用程序二进制接口(ABI)[2]，而高IR函数遵循LLVM约定。因此，每当静态二进制转换器找到跨越IR级别的调用或返回时，它就会调用ABI适配器来生成一些适应参数和返回值的Glue IR 当高IR函数调用低IR函数时，高IR参数（类型对象）必须降低到体系结构相关的内存（堆栈/CPU寄存器）。在相反的情况下，堆栈和CPU寄存器必须提升为高IR参数。类似的考虑事项也适用于返回值。这个过程类似于序列化和反序列化LLVM类型的对象，将它们作为单词存储在表示CPU寄存器和堆栈的LLVM变量中，其中它们由低IR使用。 请注意，在序列化过程中，类型会丢失，但由于源代码中存在的高级信息，反序列化仍然有可能实现。例如，考虑一个值struct将结构传递给C函数的程序集函数。知道目标的大小和地址，适配器生成攻略 ir，从低IR复制CPU寄存器和堆叠字到高IR地址。 另一个示例是返回指针的程序集函数。在低IR中，指针作为一个简单的整数字存储在r0寄存器中。由于适配器知道预期的返回类型是一个指针，因此它可以编写执行强制转换的Glue-IR。支持所有主要的C类型。","link":"/2021/07/26/inception/"},{"title":"【论文】Looking from the mirror-evaluating iot device security through mobile companion apps","text":"论文：Looking from the mirror: evaluating iot device security through mobile companion apps 在本文中，我们提出了一个平台，可以加速脆弱设备的发现或分析，而不需要访问物理设备或其固件。我们的方法是基于两个观察结果。首先，智能家庭物联网设备供应商，特别是中小型设备供应商，通常依赖相同的组件（例如，由开源项目构建的软件，来自公共供应商的硬件组件）来构建他们的设备。因此，同样的漏洞或糟糕的安全做法通常会从一个物联网设备转移到另一个物联网设备。因此，我们可以通过评估其与已知脆弱设备的相似性，将漏洞信息传播到未知设备。其次，设备的相似之处经常反映在它们的移动伙伴应用程序中，它们可以广泛访问。结合这两种观察结果，我们能够构建一个平台，以可伸缩的方式识别脆弱的设备，而不需要物理设备本身或其固件映像。 在我们的平台中，我们试图通过提供两个功能来加快识别脆弱设备的过程：(1)应用程序分析：通过分析其配套应用程序来查找设备的特性；(2）跨应用程序分析：查找设备系列，即。通过分析多个应用程序，对分析应用程序中发现的一些特性具有相似性。群类有助于识别基于共享组件的具有类似漏洞集的应用程序[8]。 1、物联网应用程序数据库，它存储了从谷歌播放商店[3]爬来的智能家庭物联网设备的配套应用程序。 2、由应用程序分析引擎进行分析。应用程序分析引擎的目标是基于代码分析来估计物联网设备的外形（即该设备的外形）。具体地说，应用程序分析引擎计算了三件事：设备的网络接口、设备可能包含的唯一字符串（称为印记），以及配套应用程序的代码签名。应用分析引擎的结果存储在应用分析数据库中。 3、跨应用程序分析引擎会查询应用程序分析数据库，并识别不同设备之间的相关性，以构建一个设备系列。一个设备系列根据它们的相似性将来自不同供应商的不同设备组合在一起。相似性可以在于不同的维度（例如，类似的软件、类似的硬件、类似的协议和类似的云后端服务）。该设备系列允许在类似设备之间传播漏洞信息。1)对于特定设备，相似性允许快速评估设备是否脆弱，如果是，针对哪些漏洞，2)针对特定漏洞，找到市场上可能受该漏洞影响的设备集 4、为了方便漏洞确认，我们的平台包含了一个称为设备固件收集器的附加组件。它利用应用程序分析引擎输出的代码分析结果(如固件URL)以及互联网搜索结果将固件映像下载到设备固件数据库中。这些固件映像后来使我们能够进一步确认跨应用程序分析引擎发现的漏洞。 采样选种子app，使用滚雪球采样，（关键字，推荐人群等等），误差大。为了消除数据集中的这种噪声，我们进行了过滤。过滤基于集群模型，该模型根据应用程序在安装时请求的权限和应用程序在运行时可能调用的敏感API对应用程序进行集群分类 应用程序分析引擎应用程序分析引擎将分析收集到的移动应用程序，以便为单个设备构建设备配置文件。与之前关注应用程序本身的工作[12,60]不同，这里的目标是从应用程序间接地计算设备的样子。我们通过独立应用三种方法来实现这一目标：计算设备网络接口的设备接口分析，计算与设备可能相关的唯一字符串的印记分析，以及计算移动伙伴应用程序的代码签名的模糊哈希分析。在实践中，我们发现第一种方法更全面和信息更丰富。然而，其余两种方法在填补第一种方法难以轻易应用的空白时仍然很有用。 设备接口分析设备接口通常很好地反映了设备的样子，例如，设备所说的协议、设备运行的服务、设备支持的功能，以及有时设备正在使用的硬件组件。在不直接检查设备或其固件的情况下，我们基于对设备的移动设备app的分析来估计设备接口 使用一种反向方法来计算应用程序的网络接口，从应用程序可能接收到的网络响应消息开始，因为这些消息是设备输出的信息。我们首先在应用程序中识别消息处理功能，并静态地决定响应消息可能是什么样子的。然后，我们确定可能触发响应的请求。最后，我们部分实例化并执行应用程序代码来重建请求。 响应提取过程。 我们依赖符号执行[33]来估计来自设备的响应消息的外观，而不实际运行该设备。我们首先使用Soot[51]建立了一个移动伙伴应用程序的控制依赖图(CDG)和数据依赖图(DDG)。然后，我们从安卓系统中的标准网络接收功能开始执行移动app, ==每当我们遇到一个依赖于响应消息内容的分支（例如，响应的字段根据值进行检查），我们将检查作为符号约束捕获，并叉执行。在所有执行结束后，符号约束的连接将作为响应消息的“描述”进行存储。为了使来自两个设备的响应消息相似，它们必须满足相同的一组符号约束。(看不懂)== 有效响应出现可能会导致app的ui更新或者本地注册表的更改，状态变化是终止有效相应处理的一个很好的近似值 可以产生一组小但有意义的约束，紧密描述物联网设备可能产生的有效响应。 配对请求和响应 匹配的请求和响应对通常共享一个处理函数的大型代码库（用来处理请求和响应的类和方法）这种相似性在运行时反应在堆栈上 因此，通过记录和比较应用发出请求时（即通过具体执行）的应用的执行堆栈和处理响应（即通过程序依赖图），我们可以很准确地确定多个请求发送功能中最有可能触发目标响应的请求 请求重建 在确定了匹配的请求和响应对之后，下一步是重建请求字符串。与响应不同，请求是由该应用程序产生的。因此，与一组响应的符号约束相比，我们可以重建一个完整的请求字符串。 设备接口分析产生的结果是一组请求和响应对。请求是完全或部分3个重建的请求字符串，响应是一组符号约束。如果一个设备都接受类似的请求并输出类似的响应，则说该设备具有与另一个设备相似的接口。 印记分析设备关键字、证书和密钥，非平凡的用户名和密码，以及特殊的URL。 我们构建了一个应用程序的数据依赖图，并从网络API向后检查，以找到应用程序中影响这些API参数的常量字符串。请注意，这些API用于与设备进行通信。换句话说，我们只使用唯一的字符串在与设备相关的情况下作为印记（即，它们是来自设备的请求或响应的一部分）。 跨应用程序分析引擎跨应用程序分析引擎旨在检测不同设备之间的模块化相似性。该比较旨在检测四种相似性：相似的软件组件、类似的硬件组件、类似的协议和类似的后端服务。 相似的软件组件：类似的设备接口，特别是应用程序接口，表明了不同设备的软件组件之间的强连接，例如不同供应商的设备应用可能使用同一种服务器 类似的硬件组件：比如不同供应商提供的物联网设备均具有的wifi模块，应用程序调用wifi模块的接口是相似的 类似的协议和类似的后端服务：一个特定的协议通常有它自己的请求和响应格式。同样，特定的后端服务经常公开标准API。跨应用程序分析引擎可以检测网络接口中的相似性，从而将使用相同协议或与同一后端服务使用的设备相关起来 设备固件收集器通过下载与被分析的应用程序对应的设备的固件映像，丰富了设备固件数据库。这些固件映像的目的是帮助我们确认跨应用程序分析阶段的发现。 两种抓取固件映像方式 首先，我们利用嵌入在移动配套应用程序中的固件下载链接。由于物联网设备通常是无头的（即没有键盘或屏幕来进行用户交互），因此它们通常通过配套的应用程序部署固件更新。因此，链接有时会由供应商内置到应用程序中。这样的链接通常是可以通过印记分析来提取的特殊URL。 其次，我们关注谷歌Play上的应用程序页面，它通常直接指向设备供应商，以抓取潜在的固件文件。具体地说，我们使用谷歌自定义搜索API来编程地通过供应商网站搜索固件映像文件。","link":"/2021/07/16/Looking-from-the-mirror/"},{"title":"【论文】Charm-Facilitating dynamic analysis of device drivers of mobile systems.","text":"论文：Charm: Facilitating dynamic analysis of device drivers of mobile systems. 背景：移动设备中I/O设备的设备驱动程序存在很多漏洞，使用最先进的动态分析技术，如交互式调试、模糊和记录和回放来分析这些驱动程序是困难的，效率低下的，甚至完全无法访问的分析 Charm，一个系统解决方案，促进动态分析设备驱动程序的移动系统 ==内核模糊器，如kAFL[65]或谷歌Syzkaller[7]，可以用于在操作系统内核中查找各种类型的bug，包括设备驱动程序。但存在问题== charm使安全分析人员能够在虚拟机中运行移动I/O设备驱动程序，并使用各种动态分析技术进行检查。 关键技术：魅力中的关键启用技术是远程执行移动I/O设备驱动程序。在这种技术中，我们在工作站的虚拟机中运行设备驱动程序。然后，我们拦截驱动程序与I/O设备的硬件接口的低级交互，并通过USB通道将它们路由到实际的移动系统。同样，移动系统中I/O设备的中断路由到虚拟机中的设备驱动程序。 设备和设备驱动程序的交互作用远程设备驱动程序技术要求我们在与承载I/O设备的不同物理机器上执行设备驱动程序。乍一看，这听起来像是一个不可能完成的任务。设备驱动程序与移动系统中的底层硬件密切交互 工作站管理程序中的存根模块与移动系统中的存根模块进行通信，以支持设备驱动程序与其硬件的交互。这些交互作用可分为三倍：访问I/O设备的寄存器、中断和直接内存访问(DMA)。Charm目前支持前两个功能: 寄存器访问权限：使用工作站中的管理程序，我们拦截设备驱动程序对其寄存器的访问。在寄存器写入时，我们将要写入的值转发到移动系统中的存根中。在寄存器读取时，我们向存根模块发送一个读取请求，接收响应，并将其返回给虚拟机中的设备驱动程序。 中断：移动系统中的（stub module）存根模块代表远程驱动程序注册一个中断处理程序。每当移动系统中相应的I/O设备触发中断时，移动存根将中断转发到工作站中的存根，然后将其注入虚拟机供设备驱动程序处理。设备驱动程序的初始化要使设备驱动程序在虚拟机的内核中得到初始化，内核必须检测到系统中相应的I/O设备。因此，要使远程设备驱动程序在虚拟机中初始化，必须使虚拟机内核“检测”连接到虚拟机的相应I/O设备。ARM和x86机器使用不同的方法进行输入/输出设备的检测。在ARM机器中，使用设备树，它是包含系统中硬件组件列表的软件清单。在此机器中，内核会在启动时解析设备树并初始化相应的设备驱动程序。在x86机器中，硬件检测主要通过高级配置和电源接口(ACPI)来使用。在x86虚拟机中，由虚拟机管理程序模拟ACPI接口。 我们有x86内核解析，并使用设备树。也就是说，我们首先允许内核完成其基于ACPI的设备检测。在那之后，内核会解析用来检测远程I/O设备的设备树。我们只需要将与感兴趣的I/O设备对应的设备树条目从移动系统的设备树复制到虚拟机的设备树上。 低延迟的USB通道我们实现了一个低级的和定制的USB通道的魅力。在这个通道中，我们为魅力创建了一个USB小工具界面[13]，并将5个端点附加到这个界面上。有两个端点用于进行寄存器访问的双向通信。两个端点用于RPC调用的双向通信（详见4.4）。最后一个端点用于进行中断的单向通信（从移动系统到工作站）。无论是在移动系统中还是在工作站中，我们的存根模块都直接在内核（工作站中的主机操作系统内核）中读写到这些端点，从而避免了昂贵的用户/内核交叉，显著减少了延迟。 依赖关系设备驱动程序不仅仅是与输入/输出设备的硬件接口进行交互。它经常与移动系统中的其他内核模块进行交互。我们使用两个解决方案来解决这些依赖关系。 首先，如果移动系统本身不需要内核模块，我们也将该模块移动到工作站虚拟机上。移动到虚拟机上的模块越多，我们就能更好地分析设备驱动程序的行为。 其次，如果移动系统上需要一个模块，我们将该模块保留在移动系统中，并实现一个远程过程调用(RPC)接口，以便虚拟机中的驱动程序与之通信。我们已经确定了无法移动到虚拟机上的最小内核模块集。我们将这些模块称为“常驻模块”。 将设备驱动程序移植到charm之中step1:第一步是将设备驱动程序添加到charm中的虚拟机的内核中 step2：第二步是将与I/O设备硬件对应的设备树条目从移动系统的设备树移动到虚拟机的设备树上。 step3：第三步是配置charm，将驱动程序的I/O操作远程操作到相应的移动系统。这包括确定相应的I/O设备的寄存器页面的物理地址（可使用移动系统的设备树轻松确定），以及设置与移动系统中的模块交互所需的RPC接口。 Step4：最后一步是配置移动系统以处理远程操作。首先，charm的（stub）存根需要移植到移动系统的内核中。这个步骤很简单，需要添加一个内核模块并配置USB接口以与该模块一起工作。其次，必须在虚拟机中禁用移植到虚拟机的设备驱动程序（因为我们不能有两个设备驱动程序管理相同的","link":"/2021/07/15/charm/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"}],"categories":[]}