{"pages":[],"posts":[{"title":"【基础知识】HTML-DOM节点","text":"DOM结点 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 HTML DOM 方法 我们可以在节点（HTML 元素）上执行的动作。 123getElementById(id) - 获取带有指定 id 的节点（元素）appendChild(node) - 插入新的子节点（元素）removeChild(node) - 删除子节点（元素） HTML DOM 属性 我们可以在节点（HTML 元素）设置和修改的值。 1234innerHTML - 节点（元素）的文本值parentNode - 节点（元素）的父节点childNodes - 节点（元素）的子节点attributes - 节点（元素）的属性节点 nodeValue - 节点的值 元素节点的nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 nodeType - 节点的类型 返回节点类型 元素类型 NodeType 元素 1 属性 2 文本 3 注释 8 文档 9 HTML DOM访问getElementById() 方法 getElementById() 方法返回带有指定 ID 的元素引用： 1x=document.getElementById(&quot;id&quot;); getElementsByTagName() 方法 getElementsByTagName() 返回带有指定标签名的所有元素。 1x=document.getElementsByTagName(&quot;p&quot;);","link":"/2021/05/26/HTML%20DOM/"},{"title":"【论文】Looking from the mirror-evaluating iot device security through mobile companion apps","text":"论文：Looking from the mirror: evaluating iot device security through mobile companion apps 在本文中，我们提出了一个平台，可以加速脆弱设备的发现或分析，而不需要访问物理设备或其固件。我们的方法是基于两个观察结果。首先，智能家庭物联网设备供应商，特别是中小型设备供应商，通常依赖相同的组件（例如，由开源项目构建的软件，来自公共供应商的硬件组件）来构建他们的设备。因此，同样的漏洞或糟糕的安全做法通常会从一个物联网设备转移到另一个物联网设备。因此，我们可以通过评估其与已知脆弱设备的相似性，将漏洞信息传播到未知设备。其次，设备的相似之处经常反映在它们的移动伙伴应用程序中，它们可以广泛访问。结合这两种观察结果，我们能够构建一个平台，以可伸缩的方式识别脆弱的设备，而不需要物理设备本身或其固件映像。 在我们的平台中，我们试图通过提供两个功能来加快识别脆弱设备的过程：(1)应用程序分析：通过分析其配套应用程序来查找设备的特性；(2）跨应用程序分析：查找设备系列，即。通过分析多个应用程序，对分析应用程序中发现的一些特性具有相似性。群类有助于识别基于共享组件的具有类似漏洞集的应用程序[8]。 1、物联网应用程序数据库，它存储了从谷歌播放商店[3]爬来的智能家庭物联网设备的配套应用程序。 2、由应用程序分析引擎进行分析。应用程序分析引擎的目标是基于代码分析来估计物联网设备的外形（即该设备的外形）。具体地说，应用程序分析引擎计算了三件事：设备的网络接口、设备可能包含的唯一字符串（称为印记），以及配套应用程序的代码签名。应用分析引擎的结果存储在应用分析数据库中。 3、跨应用程序分析引擎会查询应用程序分析数据库，并识别不同设备之间的相关性，以构建一个设备系列。一个设备系列根据它们的相似性将来自不同供应商的不同设备组合在一起。相似性可以在于不同的维度（例如，类似的软件、类似的硬件、类似的协议和类似的云后端服务）。该设备系列允许在类似设备之间传播漏洞信息。1)对于特定设备，相似性允许快速评估设备是否脆弱，如果是，针对哪些漏洞，2)针对特定漏洞，找到市场上可能受该漏洞影响的设备集 4、为了方便漏洞确认，我们的平台包含了一个称为设备固件收集器的附加组件。它利用应用程序分析引擎输出的代码分析结果(如固件URL)以及互联网搜索结果将固件映像下载到设备固件数据库中。这些固件映像后来使我们能够进一步确认跨应用程序分析引擎发现的漏洞。 采样选种子app，使用滚雪球采样，（关键字，推荐人群等等），误差大。为了消除数据集中的这种噪声，我们进行了过滤。过滤基于集群模型，该模型根据应用程序在安装时请求的权限和应用程序在运行时可能调用的敏感API对应用程序进行集群分类 应用程序分析引擎应用程序分析引擎将分析收集到的移动应用程序，以便为单个设备构建设备配置文件。与之前关注应用程序本身的工作[12,60]不同，这里的目标是从应用程序间接地计算设备的样子。我们通过独立应用三种方法来实现这一目标：计算设备网络接口的设备接口分析，计算与设备可能相关的唯一字符串的印记分析，以及计算移动伙伴应用程序的代码签名的模糊哈希分析。在实践中，我们发现第一种方法更全面和信息更丰富。然而，其余两种方法在填补第一种方法难以轻易应用的空白时仍然很有用。 设备接口分析设备接口通常很好地反映了设备的样子，例如，设备所说的协议、设备运行的服务、设备支持的功能，以及有时设备正在使用的硬件组件。在不直接检查设备或其固件的情况下，我们基于对设备的移动设备app的分析来估计设备接口 使用一种反向方法来计算应用程序的网络接口，从应用程序可能接收到的网络响应消息开始，因为这些消息是设备输出的信息。我们首先在应用程序中识别消息处理功能，并静态地决定响应消息可能是什么样子的。然后，我们确定可能触发响应的请求。最后，我们部分实例化并执行应用程序代码来重建请求。 响应提取过程。 我们依赖符号执行[33]来估计来自设备的响应消息的外观，而不实际运行该设备。我们首先使用Soot[51]建立了一个移动伙伴应用程序的控制依赖图(CDG)和数据依赖图(DDG)。然后，我们从安卓系统中的标准网络接收功能开始执行移动app, ==每当我们遇到一个依赖于响应消息内容的分支（例如，响应的字段根据值进行检查），我们将检查作为符号约束捕获，并叉执行。在所有执行结束后，符号约束的连接将作为响应消息的“描述”进行存储。为了使来自两个设备的响应消息相似，它们必须满足相同的一组符号约束。(看不懂)== 有效响应出现可能会导致app的ui更新或者本地注册表的更改，状态变化是终止有效相应处理的一个很好的近似值 可以产生一组小但有意义的约束，紧密描述物联网设备可能产生的有效响应。 配对请求和响应 匹配的请求和响应对通常共享一个处理函数的大型代码库（用来处理请求和响应的类和方法）这种相似性在运行时反应在堆栈上 因此，通过记录和比较应用发出请求时（即通过具体执行）的应用的执行堆栈和处理响应（即通过程序依赖图），我们可以很准确地确定多个请求发送功能中最有可能触发目标响应的请求 请求重建 在确定了匹配的请求和响应对之后，下一步是重建请求字符串。与响应不同，请求是由该应用程序产生的。因此，与一组响应的符号约束相比，我们可以重建一个完整的请求字符串。 设备接口分析产生的结果是一组请求和响应对。请求是完全或部分3个重建的请求字符串，响应是一组符号约束。如果一个设备都接受类似的请求并输出类似的响应，则说该设备具有与另一个设备相似的接口。 印记分析设备关键字、证书和密钥，非平凡的用户名和密码，以及特殊的URL。 我们构建了一个应用程序的数据依赖图，并从网络API向后检查，以找到应用程序中影响这些API参数的常量字符串。请注意，这些API用于与设备进行通信。换句话说，我们只使用唯一的字符串在与设备相关的情况下作为印记（即，它们是来自设备的请求或响应的一部分）。 跨应用程序分析引擎跨应用程序分析引擎旨在检测不同设备之间的模块化相似性。该比较旨在检测四种相似性：相似的软件组件、类似的硬件组件、类似的协议和类似的后端服务。 相似的软件组件：类似的设备接口，特别是应用程序接口，表明了不同设备的软件组件之间的强连接，例如不同供应商的设备应用可能使用同一种服务器 类似的硬件组件：比如不同供应商提供的物联网设备均具有的wifi模块，应用程序调用wifi模块的接口是相似的 类似的协议和类似的后端服务：一个特定的协议通常有它自己的请求和响应格式。同样，特定的后端服务经常公开标准API。跨应用程序分析引擎可以检测网络接口中的相似性，从而将使用相同协议或与同一后端服务使用的设备相关起来 设备固件收集器通过下载与被分析的应用程序对应的设备的固件映像，丰富了设备固件数据库。这些固件映像的目的是帮助我们确认跨应用程序分析阶段的发现。 两种抓取固件映像方式 首先，我们利用嵌入在移动配套应用程序中的固件下载链接。由于物联网设备通常是无头的（即没有键盘或屏幕来进行用户交互），因此它们通常通过配套的应用程序部署固件更新。因此，链接有时会由供应商内置到应用程序中。这样的链接通常是可以通过印记分析来提取的特殊URL。 其次，我们关注谷歌Play上的应用程序页面，它通常直接指向设备供应商，以抓取潜在的固件文件。具体地说，我们使用谷歌自定义搜索API来编程地通过供应商网站搜索固件映像文件。","link":"/2021/07/16/Looking-from-the-mirror/"},{"title":"【Python】Python基础知识","text":"变量和简单数据类型变量 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头 变量名不能包含空格，但可使用下划线来分隔其中的单词。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词， 变量名应既简短又具有描述性。例如，name比n好 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。 字符串 方法title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写 将字符串改为全部大写upper()或全部小写lower() 要在字符串中插入变量的值，可在前引号前加上字母f””，再将要插入的变量放在花括号内。这样，当Python显示字符串时，将把每个变量都替换为其值. 12name = &quot;Lily&quot;sen = f&quot;Hello {name}, I like Python very much&quot; 这种字符串名为f字符串。f是format（设置格式）的简写，因为Python通过把花括号内的变量替换为其值来设置字符串的格式 要在字符串中添加制表符，可使用字符组合\\t 要在字符串中添加换行符，可使用字符组合\\n 要确保字符串末尾没有空白，可使用方法rstrip(),你还可以剔除字符串开头的空白，或者同时剔除字符串两边的空白。为此，可分别使用方法lstrip()和strip() 数 Python使用两个乘号表示乘方运算 Python将所有带小数点的数称为浮点数 将任意两个数相除时，结果总是浮点数，即便这两个数都是整数且能整除： 无论是哪种运算，只要有操作数是浮点数，Python默认得到的总是浮点数，即便结果原本为整数也是如此 书写很大的数时，可使用下划线将其中的数字分组，使其更清晰易读 12a = 14_0000_0000print(a) -&gt; 1400000000 当你打印这种使用下划线定义的数时，Python不会打印其中的下划线 Python没有内置的常量类型，但Python程序员会使用全大写来指出应将某个变量视为常量，其值应始终不变12FAVORITE_NUM = 10print(&quot;最喜欢的数是：&quot; + str(FAVORITE_NUM)) 列表 列表由一系列按特定顺序排列的元素组成。在Python中，用方括号（[]）表示列表，并用逗号分隔其中的元素。 Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返回最后一个列表元素。这种约定也适用于其他负数索引。例如，索引-2返回倒数第二个列表元素，索引-3返回倒数第三个列表元素，依此类推 方法append()将元素添加到列表末尾 使用方法insert()可在列表的任何位置添加新元素 1insert(index, value) 如果知道要删除的元素在列表中的位置，可使用del语句。使用del可删除任意位置处的列表元素，条件是知道其索引 123# deldel names[1]print(names) 方法pop()删除列表末尾的元素，并让你能够接着使用它。术语弹出（pop）源自这样的类比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。实际上，可以使用pop()来删除列表中任意位置的元素，只需在圆括号中指定要删除元素的索引即可 12345678#pop()last_name = names.pop()print(last_name)print(names)# pop(index)second_name = names.pop(1)print(second_name)print(names) 如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()。 方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除 123#remove()names.remove('snn')print(names) Python方法sort()让你能够较为轻松地对列表进行排序。方法sort()永久性地修改列表元素的排列顺序。还可以按与字母顺序相反的顺序排列列表元素，只需向sort()方法传递参数reverse=True即可。 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]cars.sort()cars.sort(reverse = True) 要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()。如果要按与字母顺序相反的顺序显示列表，也可向函数sorted()传递参数reverse=True。 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]print(sorted(cars))print(sorted(cars, reverse = True)) 要反转列表元素的排列顺序，可使用方法reverse()。方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调用reverse()即可 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]cars.reverse()print(cars) 使用函数len()可快速获悉列表的长度 每当需要访问最后一个列表元素时，都可使用索引-1。仅当列表为空时，这种访问最后一个元素的方式才会导致错误 操作列表 Python根据缩进来判断代码行与前一个代码行的关系。 for语句末尾的冒号告诉Python，下一行是循环的第一行 Python函数range()让你能够轻松地生成一系列数。例如，可以像下面这样使用函数range()来打印一系列数。函数range()让Python从指定的第一个值开始数，并在到达你指定的第二个值时停止。 12nums = list(range(0,10))print(nums) 使用函数range()时，还可指定步长 12numss = list(range(0, 10, 2))print(numss) ==列表解析==将for循环和创建新元素的代码合并成一行，并自动附加新元素，请注意，这里的for语句末尾没有冒号 12squ = [value ** 2 for value in range(0, 3)]print(squ) 处理列表的部分元素，Python称之为==切片==，要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range()一样，Python在到达第二个索引之前的元素后停止。如果没有指定第一个索引，Python将自动从列表开头开始。 12345names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]print(names[0:3])print(names[:3])print(names[2:])print(names[-3:]) 可在表示切片的方括号内指定第三个值。这个值告诉Python在指定范围内每隔多少元素提取一个。 12names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]print(names[0:4:3]) 要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]） 12345names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]other_names = names[:] #复制列表使用切片 而非赋值other_names.append(&quot;lmy&quot;)print(other_names)print(names) ==使用赋值语句实际上是将两个变量指向同一个列表== Python将不能修改的值称为不可变的，而不可变的列表被称为==元组==，元组看起来很像列表，但使用圆括号而非中括号来标识。 123turp = (1,3)print(turp[0])print(turp[1]) 严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含一个元素的元组，必须在这个元素后面加上逗号。 12turp = (1,)print(turp[0]) 虽然不能修改元组的元素，但可以给存储元组的变量赋值 1234567turp = (1,3)print(turp[0])print(turp[1])turp = (2,5)print(turp[0])print(turp[1]) 如果需要存储的一组值在程序的整个生命周期内都不变，就可以使用元组 if语句 每条if语句的核心都是一个值为True或False的表达式，这种表达式称为==条件测试== 在Python中检查是否相等时区分大小写。 有时候需要在两个条件都为True时才执行相应的操作，而有时候只要求一个条件为True。在这些情况下，关键字and和or可助你一臂之力 要判断特定的值是否已包含在列表中，可使用关键字in。 还有些时候，确定特定的值未包含在列表中很重要。在这种情况下，可使用关键字not in。 Python只执行if-elif-else结构中的一个代码块 else是一条包罗万象的语句，只要不满足任何if或elif中的条件测试，其中的代码就会执行。这可能引入无效甚至恶意的数据。如果知道最终要测试的条件，应考虑使用一个elif代码块来代替else代码块 在运行for循环前确定列表是否为空很重要 在if语句中将列表名用作条件表达式时，Python将在列表至少包含一个元素时返回True，并在列表为空时返回False。 12345num = []if num: print(&quot;yes&quot;)else: print(&quot;no&quot;) 字典 在Python中，字典是一系列==键值对==。每个键都与一个值相关联，你可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。 在Python中，字典用放在花括号（{}）中的一系列键值对表示，键和值之间用冒号分隔，而键值对之间用逗号分隔 12name_age = {'zyx': 22, 'lmy': 23}print(name_age) 要获取与键相关联的值，可依次指定字典名和放在方括号内的键12name_age = {'zyx': 22, 'lmy': 23}print(name_age['zyx']) 字典是一种动态结构，可随时在其中添加键值对,要添加键值对，可依次指定字典名、用方括号括起的键和相关联的值 1234name_age = {'zyx': 22, 'lmy': 23}print(name_age)name_age['snn'] = 23 #新增键值对name_age['xxf'] = 23 对于字典中不再需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键.==删除的键值对会永远消失==。 123name_age = {'zyx': 22, 'lmy': 23}del name_age['lmy']print(name_age) 使用放在方括号内的键从字典中获取值时，可能会引发问题：如果指定的键不存在就会出错。方法get()的第一个参数用于指定键，是必不可少的；第二个参数为指定的键不存在时要返回的值，是可选的. 123name_age = {'zyx': 22, 'lmy': 23}other_name = name_age.get('nn', 'no such name') #get 方法print(other_name) 如果指定的键有可能不存在，应考虑使用方法get()，而不要使用方括号表示法7. for语句的第二部分包含字典名和方法items()，它返回一个键值对列表; 在不需要使用字典中的值时，方法keys()很有用。方法keys()并非只能用于遍历：实际上，它返回一个列表，其中包含字典中的所有键. 在只需要值时，使用方法values() 可使用函数sorted()来获得按特定顺序排列的键列表的副本. 最终的列表可能包含大量重复项。为剔除重复项，可使用集合（set）。集合中的每个元素都必须是独一无二的： 123456789101112my = {&quot;firstname&quot;: 'z', 'lastname': 'yx', &quot;age&quot;: 22, 'city': 'hangzhou', &quot;num&quot;: 22}for key,value in my.items():# 遍历键值对 print(f&quot;key is {key}&quot;) print(f&quot;value is {value}&quot;)for k in my.keys(): #只输出键 print(f&quot;key is {k}&quot;)for k in sorted(my.keys()): #排序后的键 print(f&quot;key is {k}&quot;)for v in my.values(): #只输出键 print(f&quot;value is {v}&quot;)for v in set(my.values()): #只输出键 print(f&quot;value is {v}&quot;) 可使用一对花括号直接创建集合，并在其中用逗号分隔元素（不含重复元素，集合） 12my = {1, 2, 3, 2} #集合print(my) 有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为==嵌套== 用户输入和while循环 函数input()接受一个参数——要向用户显示的提示（prompt）或说明，让用户知道该如何做。 12mes = input(&quot;输入姓名&quot;)print(mes) 使用函数input()时，Python将用户输入解读为字符串。将==数值输入用于计算和比较前，务必将其转换为数值==表示 求模运算符（%）是个很有用的工具，它将两个数相除并返回余数 12345num = input(&quot;input num: &quot;)if int(num) % 10 == 0: print(&quot;yes&quot;)else: print(&quot;no&quot;) 在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量称为==标志（flag）==，充当程序的交通信号灯 要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句 要返回循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环 for循环是一种遍历列表的有效方式，但不应在for循环中修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环","link":"/2021/06/23/Python/"},{"title":"【Web安全】SQL注入","text":"原理前端对用户输入的数据没有做合法性检查，然后参数带入了数据库查询。攻击者可以构建不同的sql语句对数据库进行操作 MySQL相关的知识点三个重要的表名 SCHEMATA 存储用户创建的所有数据库的库名 SCHEMATA_NAME TABLES 存储用户创建的所有库的库名和表名 TABLE_SCHEMA TABLE_NAME COLUMNS 库名 表名 和字段名 TABLE_SCHEMA TABLE_NAME COLUMN_NAME MySQL的常用查询语句 select 12345SELECT〈目标列组〉 FROM〈数据源〉 [WHERE〈元组选择条件〉] [GROUP BY〈分列组〉[HAVING 〈组选择条件〉]] [ORDER BY〈排序列1〉〈排序要求1〉 [，…n]]； limit 1limit m,n # 从m开始取n条记录 常用函数 123database()version()user() 注释符 123#内联注释/*!code*/ 注入手段union联合注入 判断注入点 12and 1=1and 1=2 order by判断字段数 1id = 1 order by 4 #出错的话字段数就是数字-1 常用的 12union select 1, database()... boolean注入例如： 12vince' and length(database()) = 7 #vince' and substr(database(), 1, 1) ='p' # 还可以使用ascii()或ord()判断第一个字符的ascii码 1vince' and ascii(substr(database(),1,1))=112# 报错注入攻击利用错误返回 12341' and updatexml(1, concat(1, (select user())), 1) #updatexml(文档对象，xpath，修改后的值)concat(a,b,c) 多个字符串拼接为一个 目的是不符合xpath格式 时间盲注1vince' and if(length(database()&gt; 3), sleep(5), 1) 通过判断是否出现休眠情况来判断输入的条件是否满足 堆叠查询注入堆叠查询可以执行多条语句，各个语句之间分号分割 1';select if(substr(database(), 1, 1) = 'p', sleep(5), 1) 二次注入攻击宽字节注入、当存在转义字符，数据库编码方式为GBK时，可以进行宽字节注入 在单引号前加%df, 因为/的GBK编码为%5c 加起来是一个繁体字编码，所以单引号可以逃逸 1kobe%df' or 1=1# cookie注入攻击1.寻找形如“.asp?id=xx”类的带参数的URL。 2.去掉“id=xx”查看页面显示是否正常，如果不正常，说明参数在数据传递中是直接起作用的。如果正常，则说明使用cookie作为参数传递。 3.使用burp抓包并构造payload 4.使用常规注入语句进行注入即可。 base64注入攻击url中参数经过了base64编码 XFF注入攻击http请求 头中有一个X-Forwarded-for参数，简称XFF头代表客户端的真实ip 可以修改该值伪造客户端ip进行注入。 SQL绕过技术 大小写绕过：可能存在过滤and order等，试试大写其中的字母 双写绕过 anandd oorrder 编码绕过 内联注释 1’ /*! and*/ 1=1 编码 等价函数替换 比如 version()等价@@versionSQL防御 过滤危险字符 使用预编译语句：例如 pdo预编译 使用足够安全的编码函数","link":"/2021/08/27/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%8D%E4%B9%A0/"},{"title":"【论文】Charm-Facilitating dynamic analysis of device drivers of mobile systems.","text":"论文：Charm: Facilitating dynamic analysis of device drivers of mobile systems. 背景：移动设备中I/O设备的设备驱动程序存在很多漏洞，使用最先进的动态分析技术，如交互式调试、模糊和记录和回放来分析这些驱动程序是困难的，效率低下的，甚至完全无法访问的分析 Charm，一个系统解决方案，促进动态分析设备驱动程序的移动系统 ==内核模糊器，如kAFL[65]或谷歌Syzkaller[7]，可以用于在操作系统内核中查找各种类型的bug，包括设备驱动程序。但存在问题== charm使安全分析人员能够在虚拟机中运行移动I/O设备驱动程序，并使用各种动态分析技术进行检查。 关键技术：魅力中的关键启用技术是远程执行移动I/O设备驱动程序。在这种技术中，我们在工作站的虚拟机中运行设备驱动程序。然后，我们拦截驱动程序与I/O设备的硬件接口的低级交互，并通过USB通道将它们路由到实际的移动系统。同样，移动系统中I/O设备的中断路由到虚拟机中的设备驱动程序。 设备和设备驱动程序的交互作用远程设备驱动程序技术要求我们在与承载I/O设备的不同物理机器上执行设备驱动程序。乍一看，这听起来像是一个不可能完成的任务。设备驱动程序与移动系统中的底层硬件密切交互 工作站管理程序中的存根模块与移动系统中的存根模块进行通信，以支持设备驱动程序与其硬件的交互。这些交互作用可分为三倍：访问I/O设备的寄存器、中断和直接内存访问(DMA)。Charm目前支持前两个功能: 寄存器访问权限：使用工作站中的管理程序，我们拦截设备驱动程序对其寄存器的访问。在寄存器写入时，我们将要写入的值转发到移动系统中的存根中。在寄存器读取时，我们向存根模块发送一个读取请求，接收响应，并将其返回给虚拟机中的设备驱动程序。 中断：移动系统中的（stub module）存根模块代表远程驱动程序注册一个中断处理程序。每当移动系统中相应的I/O设备触发中断时，移动存根将中断转发到工作站中的存根，然后将其注入虚拟机供设备驱动程序处理。设备驱动程序的初始化要使设备驱动程序在虚拟机的内核中得到初始化，内核必须检测到系统中相应的I/O设备。因此，要使远程设备驱动程序在虚拟机中初始化，必须使虚拟机内核“检测”连接到虚拟机的相应I/O设备。ARM和x86机器使用不同的方法进行输入/输出设备的检测。在ARM机器中，使用设备树，它是包含系统中硬件组件列表的软件清单。在此机器中，内核会在启动时解析设备树并初始化相应的设备驱动程序。在x86机器中，硬件检测主要通过高级配置和电源接口(ACPI)来使用。在x86虚拟机中，由虚拟机管理程序模拟ACPI接口。 我们有x86内核解析，并使用设备树。也就是说，我们首先允许内核完成其基于ACPI的设备检测。在那之后，内核会解析用来检测远程I/O设备的设备树。我们只需要将与感兴趣的I/O设备对应的设备树条目从移动系统的设备树复制到虚拟机的设备树上。 低延迟的USB通道我们实现了一个低级的和定制的USB通道的魅力。在这个通道中，我们为魅力创建了一个USB小工具界面[13]，并将5个端点附加到这个界面上。有两个端点用于进行寄存器访问的双向通信。两个端点用于RPC调用的双向通信（详见4.4）。最后一个端点用于进行中断的单向通信（从移动系统到工作站）。无论是在移动系统中还是在工作站中，我们的存根模块都直接在内核（工作站中的主机操作系统内核）中读写到这些端点，从而避免了昂贵的用户/内核交叉，显著减少了延迟。 依赖关系设备驱动程序不仅仅是与输入/输出设备的硬件接口进行交互。它经常与移动系统中的其他内核模块进行交互。我们使用两个解决方案来解决这些依赖关系。 首先，如果移动系统本身不需要内核模块，我们也将该模块移动到工作站虚拟机上。移动到虚拟机上的模块越多，我们就能更好地分析设备驱动程序的行为。 其次，如果移动系统上需要一个模块，我们将该模块保留在移动系统中，并实现一个远程过程调用(RPC)接口，以便虚拟机中的驱动程序与之通信。我们已经确定了无法移动到虚拟机上的最小内核模块集。我们将这些模块称为“常驻模块”。 将设备驱动程序移植到charm之中step1:第一步是将设备驱动程序添加到charm中的虚拟机的内核中 step2：第二步是将与I/O设备硬件对应的设备树条目从移动系统的设备树移动到虚拟机的设备树上。 step3：第三步是配置charm，将驱动程序的I/O操作远程操作到相应的移动系统。这包括确定相应的I/O设备的寄存器页面的物理地址（可使用移动系统的设备树轻松确定），以及设置与移动系统中的模块交互所需的RPC接口。 Step4：最后一步是配置移动系统以处理远程操作。首先，charm的（stub）存根需要移植到移动系统的内核中。这个步骤很简单，需要添加一个内核模块并配置USB接口以与该模块一起工作。其次，必须在虚拟机中禁用移植到虚拟机的设备驱动程序（因为我们不能有两个设备驱动程序管理相同的","link":"/2021/07/15/charm/"},{"title":"【论文】firmup","text":"我们提出了一种新的二进制代码搜索技术，可以平衡查询过程和它所在的可执行文件之间的焦点。该方法基于稳健的底层语义过程相似性，并利用了我们的关键观察结果，即过程在其可执行文件的上下文中操作。 我们提出了一种算法，用来使用可执行文件中的周围过程，通过使用来回匹配来为查询过程找到更精确的匹配。 很多指令实现相同的功能，但由于指令选择、排序和寄存器使用方面的差异以及不同的代码和数据布局（偏移）的差异，发现这种相似性变得困难。 使用切片生成集中的计算过程，用一个编译器优化器，将我们称之为链的片段带到简洁的规范形式，同时也规范化寄存器名称和基地址偏移。将过程表示为一组链允许捕获语义相似性，因为有关如何执行计算的具体细节通过转换为链被抽象出来，这只反映了所计算的内容。 Both snippets retrieve a value from the stack (line 5 in (a), line 1 in (b)). 两个代码段都从堆栈中取出一个值 Both load the value 0x1F and use it in a jump comparison operation (lines 4 and 6 in (a), lines 5 and 6 in (b)). 两者都加载值 0x1F 并在跳转比较操作中使用它 Both snippets call a procedure (line 1 in (a), line 3 in (b)). 两个代码段都调用一个函数 尽管在语义上并不等价，但这两个函数有很大的相似性，但是由于指令选择、顺序和寄存器使用的差异，以及不同的代码和数据布局(偏移量)，找到这种相似性非常困难。 我们将一对程序(q、t)的相似性定义为由这些程序共享的链的数量，并表示其Sim(q、t) 问题定义给定一个可执行文件F={T1，…，Tn}（例如，固件映像）和一个查询可执行文件Q，包含一个（脆弱的）过程qv，我们的目标是确定每个可执行文件Ti∈F是否包含与qv类似的过程。 二次调研 问题定义给定一个可执行文件F={T1，…，Tn}（例如，固件映像）和一个查询可执行文件Q，包含一个（脆弱的）过程qv，我们的目标是确定每个可执行文件Ti∈F是否包含与qv类似的过程。如果两个过程来自相同的源代码，我们将它们定义为类似的源代码。相似性可能会受到源代码（补丁、版本）的变化，并随着过程在语义上的不同而下降。F中的每个可执行文件都可以由任何编译器编译，也可以删除所有名称信息。 捕获语义相似性为了允许我们的技术找到来自不同编译的二进制文件上的相似性，我们首先在BB级别上分解一个过程(一个BB是该过程的CFG中的一个节点)，并进一步在BB级别上应用切片[30]来生成聚焦的计算片段。然后，我们使用一个编译器优化器将我们称之为链的片段变为简洁的规范形式，同时也规范化寄存器名称和基地址偏移。将一组过程表示为一组链允许捕获语义相似性。我们将一对程序(q，t)的相似性定义为这些程序共享的链数，并将其表示为Sim(q，t)。 固件二进制标示 二进制转换 从位到IR表示(IR)：使用Angr.io框架[29]及其基于Valgrind的VEX表示[25]作为我们的lift工具链。Angr.io包含一个为Valgrind的VEX-IR的包装器。Angr.io提供了来自各种架构的lift，这使我们能够在整个固件爬行过程中最常见的架构上进行操作。VEX-IR（机器码转换过来的中间表达式）包含机器状态的完整表示。我们使用IDAPro[6]从可执行文件中解析和提取过程和BBs，因为我们注意到，当任务在可执行文件中查找所有过程和块时，它更准确 转变嵌入式结构：处理四种不同的目标架构，MIPS32、ARM32、PPC32和Intel-x86，特别是来自真实固件映像的可执行文件，需要注意一些问题。 比如我们发现具ELFCLASS32头的MIPS64可执行文件（8字节对齐指令）在固件中是常见的。在MIPS可执行文件中，另一个需要注意的问题是使用了一个延迟分支插槽，这需要一个额外的指令来遵循任何分支指令。此附加指令将在解析分支目标时执行。这导致后续块的第一个指令被省略，并作为前一个块的一部分放置，从而导致链的差异。 最后，如前所述，二进制lift工具可能在某些过程中识别几个块，甚至完全省略整个过程。。我们在ELF文件的˙文本部分中添加了对CFG连接性和未占区域的覆盖率的检查。 程序分解我们的过程的分解是基于CFG表示，其中我们最初在BB级别上分解每个过程。然后通过应用切片[30]，进一步将BBs分解为独立的执行单元,这将产生几个子块，每个子块只包含计算单个输出所需的指令(在BB中计算的面向外值的UseDef链)，子块就称之为链 每个BB都被切片，直到所有的值都被覆盖为止。我们假设BB是单静态分配(SSA)的形式，这是我们使用的VEX-IR提升的一个特性。我们通过定义BB中所有指令（index）的集来初始化该过程。我们重复这个集合，在其中每一步中都选择迄今为止最后未发现的指令（top）。top被用作一条新链的基础。该链是通过向后迭代BB的指令，并仅在它定义了s使用的变量时添加每个指令来构建的。 在算法1中，我们使用RSet(i)作为指令i读取（或使用）的变量集，并使用WSet(i)作为它写入（或定义）的变量集。在任何情况下，一旦指令被任何链覆盖，它将（通过索引）从索引中删除。当我们分别处理每个BB时，一个块的输入是在在块中定义它们之前使用的变量（寄存器和内存位置）。 规范化 为了克服同一过程的不同汇编之间的语法差异，我们进一步将语义等价的链带到相同的语法形式。我们应用以下归一化和优化操作，使链成为一个简洁的规范形式： 偏移消除: 走向规范形式的第一步是删除与二进制文件的具体结构相关的偏移值。对算法产生的链进行去除. 这包括跳转地址以及指向静态部分的地址。在可执行文件中。我们不删除与堆栈和结构操作相关的偏移量，因为它们与过程的语义更相关，可以作为过程处理的数据类型的描述符。 寄存器折叠：在写入之前读取的寄存器被转换为过程的参数，由链计算的最后一个值是返回值。我们注意到，即使过程的返回值存储在寄存器中，返回的值也必须首先在过程中生成，因此将在链中捕获 编译程序优化：接下来，我们对前一个偏移消除步骤中的每个链应用LLVM选项优化器。这是通过将VEX-IR链翻译为LLVM-IR来实现的。每条链都被翻译成一个LLVM-IR函数。使用成熟的现代优化器允许链转换为一个简洁和规范的形式，这是有用的寻找相似性。相关的优化包括表达式简化、持续折叠和传播、指令组合、通用子表达式消除和死码消除。 变量名称规范化：为了进一步推进链向正则形式的发展，我们根据它们出现的顺序重命名优化链中出现的变量。这项技术的灵感来自于以前的工作，旨在寻找在计算[15]上的等价性。这个最后阶段的输出是我们用于成对过程相似度度量的规范链。我们将Strands(p)表示为规范链的集合（每条链表示为其指令的一个字符串）。 提升链（在中间）逐字保留装配操作，并为每个值操作添加一个临时变量，寄存器名称和偏移也被保留。在优化和归一化名称和偏移量后，装配链（上）的整个操作简化为LLVM-IR规范链（底）的第一个指令，将归一化寄存器reg0(以前的s5)与折叠到v0寄存器中的0x1F常数进行比较。下面的说明反映分支操作，返回归一化偏移偏移0或pc中的下一个程序计数器值。3. 两两过程相似性 在生成每个过程的链集后，我们计算成对的相似性。我们表示一个查询过程，即被搜索的过程，作为qv∈Q，其中Q是包含的查询可执行文件中所有过程的集合。 目标过程，即与候选过程q进行比较，用t∈T表示(类似地，T是包含的目标可执行文件)。给定一对(q，t)，我们将过程相似性定义如下：Sim(q，t)=|Strands(q)∩Strands(t)|，即Sim(q，t)只是两种表示中共享的唯一规范链的数量。","link":"/2021/07/05/firmup/"},{"title":"【Go】Go基础知识","text":"Go的优势 可以直接编译成机器码 不依赖其他库 可以直接部署 静态类型语言 天生支持并发 充分利用多核 强大的标准库： runtime系统调度机制，高效的GC垃圾回收 丰富的标准库 Go的基础知识 定义变量：12var name typevar i int = 1 也可以让语言自行判定： 1var i = 1 或者： 1i := 1 这种只能在函数体内出现声明多变量： 1234567var( //一般用于声明全局变量 a int b string)var a, b = 1, '123' ==字符串用双引号==2. 常量定义 1const identifier [type] = value iota特殊常量 在同一个常量组中，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引) 12345const( a = iota //0 b //1 c //2) 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。如： 123456const ( a = 1 b //1 c //1 d //1) go中没有while循环 函数定义 1234567func function_name( [parameter list(type)] ) ([return_types]) { 函数体}func add(num1 string, num2 int) (string, int) { return num1, num2} ==闭包== Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。 12345678func getSequence() func() int { i:=0 return func() int { i+=1 return i }} 数组 声明数组 123var variable_name [SIZE] variable_typevar balance [10] float32 初始化数组 123456var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}数组长度不确定时var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}或balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 指针的定义 1234var var_name *var-typevar ip *int /* 指向整型*/var fp *float32 /* 指向浮点型 */ 指针数组 1var ptr [5]*int; 指向指针的指针 1var ptr **int 8.","link":"/2021/08/09/go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"【论文】inception：一个执行完整的真实世界的嵌入式固件的安全测试的框架","text":"inception：一个执行完整的真实世界的嵌入式固件的安全测试的框架目标：利用高级源代码的语义信息来检测符号执行过程中的漏洞，同时也支持低级汇编代码和与硬件外设的频繁交互。 做了啥：Incption转换器从高级源代码、手写汇编、二进制库和部分处理器硬件行为中生成和合并LLVM位码。这种设计减少了与实际执行和手动工作之间的差异。保留了源代码语义，提高了安全检查的有效性。基于KLEE的初始符号虚拟机执行符号执行，使用几种策略来处理不同级别的内存抽象、与外设的交互和中断。最后，I调试器是Inception一个高性能的JTAG调试器，它执行对真实硬件的内存访问的重定向。 常见的符号执行环境通常运行与架构无关的代码，可以从源代码中导出，而不会丢失语义信息。或者，依赖架构的二进制代码可以提升到中间表示，至少可以部分执行到符号虚拟机，但丢失了源代码语义信息。这两种情况差异很大（例如，在它们的记忆模型中），并且不能很容易地共存。 inception由三部分组成。 首先，初始转换器，它使用lift和合并过程生成统一的LLVM-IR，将程序的组装和二进制部分集成到来自高级源的中间表示中。这个过程还考虑到了ARMv7-M体系结构的低级硬件机制。 其次，inception符号虚拟机，它能够执行这个混合级别的LLVM-IR，并处理具有不同策略的中断和内存映射外设，以适应不同的用例。它还可以根据需求生成中断，并从外围设备内存作为不受约束的符号值读取。这个虚拟机基于KLEE，这是一个著名的开源符号执行的、运行LLVM-IR位码的符号执行虚拟机。 inception调试器，这是一个自定义的快速调试器，围绕一个USB3总线适配器和一个FPGA构建。它提供了对外围设备的高速访问，并可以很容易地扩展到多个目标。 lift和合并过程图显示了我们的位码合并方法的主要阶段，以及如何将具有内联程序集1的源代码转换为一致的可以由初始VM执行的位码3。示例代码包含程序集中编写的函数的节录，该函数请求r0包含数据字节的系统调用。 代码的其余部分由调用第一个汇编函数的主函数和要发送的消息组成。使用适当的LLVM前端（CLang为C/C++），源代码1将转换为LLVM-IR位码。结果的位码2显示只有C/C++源代码已经真正被翻译成了LLVM-IR。实际上，LLVM-IR位码的最初目的是在代码降低到目标体系结构之前实现高级优化，而程序集已经处于低语义级别，无法由LLVM编译器表示或优化 为了解决这个问题，我们引入了一种新的生命和合并方法，我们在感知转换器中实现了它。该转换器以CLang生成的ELF二进制文件和LLVM-IR位码作为输入。它生成一个一致的LLVM-IR位码，其中汇编指令已被抽象到一个LLVM-IR表单。此步骤由静态升降机（static lifter）完成，它用一系列LLVM-IR指令替换每个装配指令。我们将所得到的位码称为混合语义级位码(混合IR)，如3所示，其中包含： 从C/C++源代码中获得的高语义级IR（高IR）。这主要是CLang发出的代码，该代码由程序集源文件中定义的外部全局变量扩展。我们在IR中重新分配了这些全局变量。 从程序集源代码衍生出的低语义级IR（低IR）。这部分是由我们的静态升降机自动生成的。它包含了汇编指令的转换和执行所必需的一些与体系结构相关的元素。首先，将CPU和协处理器的寄存器建模为全局变量。其次，特定的功能可以模拟了通常由CPU处理的无缝硬件机制。例如，当输入中断服务例程(ISR)时，处理器会透明地更新堆栈指针，并堆叠CPU寄存器的一个子集。当ISR返回时，上下文将自动恢复，这样，被中断挂起的代码就可以恢复了。 Glue IR，可以在高级语义和低级语义域之间进行切换。此IR位码由特定的应用程序二进制接口(ABI)适配器生成，能够提升或降级抽象级别。实际上，层之间的通信和切换主要发生在函数之间的接口上，即当高级函数调用低级函数或相反函数时。 inception符号虚拟机 由lift和合并过程产生的位码几乎是可执行的，但它仍然需要虚拟机中的一些额外的支持。主要的挑战是highIR只访问类型的变量，而不建模内存地址或指针。另一方面，从汇编指令生成的IR已经丢失了有关类型和变量的所有信息，并且只访问指针和非类型数据。另一个挑战是处理由代码使用但未分配的内存映射内存，以及不在KLEE中建模的中断和上下文开关 为了解决这些问题，我们使用内存管理器和中断管理器扩展了KLEE。在（符号）执行过程中，KLEE的原始内存监视器会对内存访问执行高级安全检查。当检测到违规时，约束求解器将生成一个可重播的测试用例 内存管理器利用ELF二进制文件和混合IR文件来构建一个统一的内存布局，其中两个语义域都可以访问内存。分配特定的数据区域以运行低IR代码，比如代码部分和一些内存部分（堆栈、堆栈、BSS）中包含的指针。每个内存地址都可配置以模拟正常固件的环境。例如，一个内存映射的位置可以被重定向到真实的外围设备，以修剪符号探索和使用真实的值。或者，它可以在虚拟机上分配，并标记为符号来模拟来自不受信任的外设的输入。初始空间还支持直接内存访问(DMA)外设，前提是每个DMA缓冲区都被标记为重定向到真正的设备内存。与其他重定向位置类似，DMA缓冲区不能保留符号值。 中断管理器通过中断执行和调用相应的中断处理程序，赋予KLEE处理中断事件的能力。使用中断向量表解决中断的地址。中断事件可以在实际硬件上收集，或者由用户在需要时生成（通过调用特殊的处理程序函数）。在第一种情况下，虚拟机和真实设备被正确地同步，以避免任何不一致。我们进一步扩展了KLEE来执行在多线程应用程序中的线程之间切换上下文的处理程序。 内存监视器和安全检查。所有的安全分析都主要依赖于KLEE的内存监视器，它能够基于与每次访问相关的语义信息对每次访问进行安全检查。监视器观察请求的语义信息（请求类型）和访问数据（访问类型）的语义信息。当有足够的信息可用时，监视器能够检测内存访问违规，例如，边界外访问、无后使用或返回后使用。来自高红外的请求和访问用高红外定义的内存元素，有足够的信息来检测大多数违规行为。相反，来自低红外的请求往往信息较少，检测率也较低。然而，由于来自高红外值的信息，仍然有可能检测到比仅使用二进制文件更多的问题。 实验和验证 lift和合并过程 为了能够将组件和二进制文件与源代码粘合成一个统一的LLVM-IR表示形式(混合-IR)，我们应用了两个不同的过程。 lift过程采用机器代码（编译汇编或二进制文件）并生成等效的中间表示（低IR）。这种表示只使用了LLVM-IR语言的低级特性，它模拟了原始架构(ARMv7-M)，其中包含了Cortex-M3处理器的一些硬件语义，比如带有副作用的指令的行为。因此，它（几乎）是自包含的，其中很大一部分可以在任何能够解释LLVM-IR的虚拟机上执行。正如以下几部分所解释的，我们向KLEE介绍了一些特性，以使这段代码完全可执行，特别是在处理上下文切换时。 我们的升降机是基于三个主要的零部件组成的。 首先，一个静态递归反汇编程序，它找到所有的指令并将其存储为内部图表示。 其次，一个简单的反编译器，包括间接分支和复杂的硬件机制（例如，从中断和上下文开关返回）。 最后，升降机静态地将给定的机器指令转换为语义上等效的LLVMIR指令序列。静态方法的一个重要优点是，它使源进一步处理源产生混合IR。此外，与在执行过程中提升指令的动态提升器相比，它具有较低的运行时开销。 合并过程采用（几乎）自含的低IR和由C/C++编译的高IR，将它们粘在一起（用一些Glue IR）。这是最具挑战性的部分，因为它们有不同层次的语义信息和不同层次的记忆视图。 因此，第一步是在KLEE虚拟机中的两个IR级别之间创建一个统一的内存布局。除此之外，外围设备地址还可以在KLEE中访问这些地址。第二步包括确定这两种表示法之间的最佳接口和在这个边界上交换数据的机制。我们选择使用应用程序二进制接口(ABI)，它以统一的方式调节函数之间的通信。我们的合并能够生成粘合IR代码，使高IR函数与低IR函数通信，反之亦然。 统一的内存布局 如何利用lift和合并过程和KLEE来创建统一的内存布局。这种内存布局是低IR和高IR共存和通信的核心。 处理器寄存器 由于不同的原因，处理器寄存器由全局变量表示。首先，LLVM-IR是一种单一静态分配(SSA)语言，其中每条指令都将其结果存储在一个唯一分配的寄存器中。其次，LLVM支持无限数量的寄存器，这些寄存器只分配一次，不能全局访问。因此，LLVM寄存器不能用于表示CPU寄存器，这些寄存器受到限制、分配多次，并通过指令全局访问。 堆当高IR代码运行时，会使用正常的KLEE堆栈。每个函数都有自己的函数框架对象，该对象包含有关执行的元数据。这包括关于调用者、SSA寄存器值（包含临时本地变量）和本地变量（使用正常KLEE机制分配）的信息。低IR代码使用了一个单独的堆栈。此堆栈被建模为一个全局整数数组，由内存管理器以与符号表的stack部分相同的地址和大小分配。 数据区域包含混合的语义级变量。实际上，当高IR分配数据时，生成的内存对象被键入并在符号表所指示的相同地址进行分配，以保持与组件代码的兼容性。另一方面，数据可以由汇编代码定义，并通过高IR访问。在这种情况下，我们使用高IR的外部声明中存在的语义信息来分配一个类型化的对象。第三种可能的情况是由程序集代码分配的数据，但从未被高级代码访问。在这种情况下，不存在语义信息，分配取决于ELF符号表中的信息。 应用程序二进制接口适配器 低IR函数遵循标准的臂应用程序二进制接口(ABI)[2]，而高IR函数遵循LLVM约定。因此，每当静态二进制转换器找到跨越IR级别的调用或返回时，它就会调用ABI适配器来生成一些适应参数和返回值的Glue IR 当高IR函数调用低IR函数时，高IR参数（类型对象）必须降低到体系结构相关的内存（堆栈/CPU寄存器）。在相反的情况下，堆栈和CPU寄存器必须提升为高IR参数。类似的考虑事项也适用于返回值。这个过程类似于序列化和反序列化LLVM类型的对象，将它们作为单词存储在表示CPU寄存器和堆栈的LLVM变量中，其中它们由低IR使用。 请注意，在序列化过程中，类型会丢失，但由于源代码中存在的高级信息，反序列化仍然有可能实现。例如，考虑一个值struct将结构传递给C函数的程序集函数。知道目标的大小和地址，适配器生成攻略 ir，从低IR复制CPU寄存器和堆叠字到高IR地址。 另一个示例是返回指针的程序集函数。在低IR中，指针作为一个简单的整数字存储在r0寄存器中。由于适配器知道预期的返回类型是一个指针，因此它可以编写执行强制转换的Glue-IR。支持所有主要的C类型。","link":"/2021/07/26/inception/"},{"title":"【linux】linux常用命令","text":"chmod 更改文件权限 处理目录 1234567891011121314151617ls（英文全拼：list files）: 列出目录及文件名cd（英文全拼：change directory）：切换目录pwd（英文全拼：print workdirectory）：显示目前的目录mkdir（英文全拼：make directory）：创建一个新的目录rmdir（英文全拼：remove directory）：删除一个空的目录cp（英文全拼：copy file）: 复制文件或目录rm（英文全拼：remove）: 删除文件或目录mv（英文全拼：move file）:移动文件与目录，或修改文件与目录的名称 文件查看 1234567cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行 查看linux版本123查看操作系统版本信息 cat /proc/versionuname -auname -m 显示32位或64位 运行 Shell 脚本有两种方法： 作为可执行程序 12345将上面的代码保存为 test.sh，并 cd 到相应目录：chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 作为解释器参数 1234这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：/bin/sh test.sh/bin/php test.php","link":"/2021/06/02/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"【linux】linux各个文件夹的用途","text":"系统启动必须： /boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。 /etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 /lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中 指令集合： /bin：存放着最常用的程序和指令 /sbin：只有系统管理员能使用的程序和指令。 外部文件管理： /dev ：Device(设备)的缩写,存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。 /media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。 /mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 临时文件： /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。 /tmp：这个目录是用来存放一些临时文件的。 账户： /root：系统管理员的用户主目录。 /home：用户的主目录，以用户的账号命名的。 /usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序与指令。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 运行过程中要用： /var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。 /proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改，占用内存而不是磁盘。 扩展用的： /opt：默认是空的，我们安装额外软件可以放在这个里面。 /srv：存放服务启动后需要提取的数据（不用服务器就是空）","link":"/2021/04/27/linux%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%A4%B9%E7%94%A8%E9%80%94/"},{"title":"【Web安全】Sqlmap基础","text":"12345678910sqlmap.py -u urlsqlmap.py -r 1.txt //不需要cookie等 text数据为web数据包sqlmap.py -u url --dbs //查看所有数据库名sqlmap.py -u url -D 数据库名 --tables //查看数据库所有表名sqlmap.py -u url -D 数据库名 -T 表名 --columns //查看所有字段名sqlmap.py -u url -D 数据库名 -T 表名 -C 字段1，字段2 --dump //查看具体的字段信息sqlmap.py -u url --users //查看所有用户sqlmap.py -u url --passwords //当前用户密码 爆破sqlmap.py -u url --current-db //当前使用的数据库sqlmap.py -u url --current-user //当前使用的用户名 123456--level 1-5 探测等级--is-dba 当前用户是否为管理员权限--roles 列出管理员权限角色 适用于Oracle 如果当前用户有权限读取所有用户的表 会列出每个用户的角色--referer HTTP Referer头可以在请求中伪造http中的referer 当level在3时 会尝试对refer注入--sql-shell 运行自定义的sql语句--os-cmd --os-shell 运行任意操作系统命令 tamper脚本 1234567sqlmap.py *** --tamper &quot;模块名&quot;base64encode.py 替换base64编码space2plus.py 空格变为+charencode.py 对给定payload字符使用URL编码","link":"/2021/10/05/sqlmap%E5%A4%8D%E4%B9%A0/"},{"title":"【基础知识】一些知识的查漏补缺","text":"1. html和xml的区别与联系html关注于将数据和显示联系起来，xml用于描述数据存储数据，其焦点是数据的内容。 2. js中eval()函数eval()函数功能是将某段字符串当成JS语句来执行。 1234var a=eval(&quot;12&quot;); //相当于 var a=12;var obj = eval(&quot;({name:'nick',age:28})&quot;); //相当于 var obj = {name:'nick',age:28};对象（包括函数等）需要放在括号中，否则会报错eval(&quot;alert('hello');&quot;); //相当于alert('hello'); 3. 富文本富文本格式（Rich Text Format,一般简称为RTF）是一种跨平台文档格式，由微软公司开发。大多数的文字处理软件都能读取和保存RTF文档。 富文本格式是一种类似DOC格式（Word文档）的文件，有很好的兼容性，使用Windows系统里面的“写字板”就能打开并进行编辑。RTF是一种非常流行的文件结构，很多文字编辑器都支持它。一般的格式设置，比如字体和段落设置，页面设置等等信息都可以存在RTF格式中能在一定程度上实现word与wps文件之间的互访 4. MVC框架V即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操作的方式。 M即model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 5. AJAX让数据在后台进行异步传输，常用的使用场景为：对网页的局部数据进行更新时，不需要刷新整个网页，以节省带宽资源。 6.浏览器中的Session机制浏览器中的Session机制 7. 数据库中substring的用法substring是用来截取要显示的字符串的例如：代码显示no列中的567890，但是你只需要知道后两位，就要重写代码： 1select substring（no，5，2） 代码中5代表从5开始截取，2代表截取两个字符串","link":"/2021/05/25/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%9A%84%20%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"title":"【Python】乱起八糟的Python知识点","text":"Python内置的==enumerate==函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身 123456 for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C 可迭代对象可以直接作用于for循环的对象统称为可迭代对象：==Iterable==123456listtupledictsetstrgenerator 以及带yield的generator function 可使用isinstance()判断是否为可迭代对象 1234567891011&gt;&gt;&gt; from collections.abc import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 迭代器可以被next()函数调用并不断返回下一个值的对象称为迭代器：==Iterator==可以使用isinstance()判断一个对象是否是Iterator对象 123456789&gt;&gt;&gt; from collections.abc import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象4. reduce用法reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 123456from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 利用filter()求素数 12345678910111213141516171819202122232425def check_su(): n = 1 while True: n += 2 yield ndef fliter_fun(n): return lambda x: x % n &gt; 0def main(): yield 2 i = check_su() while True: n = next(i) yield n i = filter(fliter_fun(n), i)for n in main(): if n &lt; 100: print(n) else: break 装饰器 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 123456789101112131415161718192021def text_input(text): def log(func): @functools.wraps(func) def wrapper(*args, **kw): print(f&quot;call {func.__name__} {text}&quot;) return func(*args, **kw) return wrapper return log@text_input('8.15')def now(): print('2021')now()print(now.__name__)---call now 8.152021now 其中去掉@functools.wraps(func)，now.name会变成wrapper 动态绑定 动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现 1234567891011class student: passs = student()s.name = 'zyx' # 动态绑定新的属性def show_name(self, name): print(name)s.show_name = MethodType(show_name, s) # 给实例动态绑定方法 from types import MethodTypestudent.show_name = show_name # 动态绑定新的函数 slots 要限制实例的属性，比如只允许对Student实例添加name和age属性，可以定义一个特殊的__slots__变量，来限制该class实例能添加的属性 1234567class student: __slots__ = (name, age)s = student()s.name = 'zyx's.age = '22's.score = 5 # 报错 ==使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的== 9.@property 10.zip()函数","link":"/2021/08/17/%E4%B9%B1%E8%B5%B7%E5%85%AB%E7%B3%9F%E7%9A%84python%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"【Web安全】信息收集的一些资料","text":"信息收集域名信息收集whois：查询域名是否被注册以及详细信息 备案信息查询：ICP备案查询网 天眼查 收集敏感信息google burp的repeater github 收集子域名信息子域名检测工具：Layer子域名挖掘机 subDomainsBrute Sublist3r 搜索引擎枚举：site:baidu.com 第三方聚合应用枚举：DNSdumpster 证书透明度公开日志枚举：crt.sh 和 censys.. 收集常用端口信息Nmap Masscan Zmap 御剑高速tcp端口扫描工具 查找真实IPCDN：内容分发网络，解决因传输距离和不同运营商节点造成的网络速度性能地下的问题（将经常访问的静态资源放在附近的CDN服务器上），采用CDN的话ping目标域名会得的离我们最近的目标节点的CDN服务器 通过ping判断是否使用了CDN或者利用17CE进行全国多地区ping的ip结果比对，都是一样的就可能未使用CDN 绕过CDN寻找真实IP 内部邮箱源 扫描网站测试文件 eg：phpinfo, test等 分站域名 有些网站主站有CDN 分站可能没有 国外访问 App Synthetic Monitor 查询域名解析记录 通过NETCRAFT观察IP历史记录 目标网站有自己app，可以抓取app请求包 12345指纹识别：网站CMS指纹识别 web容器指纹识别CMS：整站系统或文章系统 Dedecms PHPWEB Discuz PHPWind 御剑Web指纹识别 WhatWeb WebRobo 在线工具：BugScaner 云悉指纹 WhatWeb 验证IP 直接IP访问 收集敏感目录文件DirBuster 御剑后台扫描珍藏版 wwwscan spinder.py Sensitivefilescan Weakfilescan Webscan（在线工具）","link":"/2021/05/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"title":"【基础知识】密码学基础知识","text":"1. 对称加密和非对称加密的区别 对称加密使用同一密钥，非对称加密使用两个密钥，公钥和私钥 对称加密一般耗时短，非对称加密耗时长 对称加密存在密钥传输安全性问题，非对称公钥可公开2. DES一种用56位密钥来加密分组长度为64位数据的对称密钥算法（实际上函数要求一个64位的密钥作为输入，但是第8、16、24、32、40、48、56、64 等8位是校验位， 使得每个密钥都有奇数个 1，所以参与加密过程的只有56位） 初始置换ip 把64位数据乱序 然后分左右l和r 通过置换表置换出来 乘积变换 16轮 每轮需要48bit的子密钥 扩展运算 扩展到48位 子密钥加密 s盒压缩 变为32bit p盒置换 初始逆置换 是初始置换ip的逆置换 解密过程16轮子密钥要把顺序反过来 分组模式ECB:每个明文组独立地以同一密钥加密 CBC:加密算法的输入是当前明文组与前一密文组的异或 CFB：每次只处理输入的j比特，将上一次的密文用作加密算法的输入以产生伪随机输出，该输出再与当前明文异或以产生当前密文 OFB：与CFB类似，不同之处是本次加密算法的输入为前一次加密算法的输出 ECB CBC 简单；有利于并行计算；误差不会被传递； 不容易主动攻击，安全性好于ECB 明文重复信息会暴露 需要初始化向量 不利于并行计算 误差传递 3. AESAES的区块长度固定为128比特，密钥长度则可以是128，192或256比特； 字节代换：状态矩阵跟s盒做字节代换 行移位 状态矩阵行循环左移 0移0 1移1… 列混淆 状态矩阵和常量矩阵相乘 轮密钥加 与加密矩阵进行异或 数字签名的原理","link":"/2021/11/27/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"【Python】流畅的Python读书笔记","text":"切片的表达式 1object[start_index:end_index:step] step：正负数均可，其绝对值大小决定了切取数据时的‘‘步长”，而正负号决定了“切取方向”，正表示“从左往右”取值，负表示“从右往左”取值。当step省略时，默认为1，即从左往右以步长1取值。 sorted函数如果要按照某个规则排序，则需指定参数 key， key 是一个函数对象 例如字符串构成的列表，我想按照字符串的长度来排序 123chars = ['Andrew', 'This', 'a', 'from', 'is', 'string', 'test']print(sorted(chars, key=len)) 匿名函数 不需要显示的指定函数名 123calc = lambda n: n**nlambda表示匿名函数n表示函数参数 比如 123456789101112131415161718#这段代码def calc(x,y): return x**y#换成匿名函数calc = lambda x,y:x**yprint(calc(2,5))#三元运算def calc(x,y): if x &gt; y: return x*y else: return x / y #三元运算换成匿名函数calc = lambda x,y:x * y if x &gt; y else x / yprint(calc(2,5)) map()函数 map() 会根据提供的函数对指定序列做映射。 1map(function, iterable, ...) 第一个参数 function 以参数序列中的每一个元素调用 function 函数 123456789def square(x) : # 计算平方数... return x ** 2...&gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方&lt;map object at 0x100d3d550&gt; # 返回迭代器&gt;&gt;&gt; list(map(square, [1,2,3,4,5])) # 使用 list() 转换为列表[1, 4, 9, 16, 25]&gt;&gt;&gt; list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) # 使用 lambda 匿名函数[1, 4, 9, 16, 25] filter()函数 filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器对象。 1filter(function, iterable) 比如 123456def is_odd(n): return n % 2 == 1 tmplist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])newlist = list(tmplist)print(newlist) 迭代器与生成器 12345678910def test(): yield 1 a = 1 + 1 yield a yield 3res = test()print(next(res)) # 1print(next(res)) # 2print(res.__next__()) #3","link":"/2021/08/13/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"title":"【论文】找的一些终端方面的论文","text":"4.12-4.16 电力系统移动终端的安全评估 2018 ICCSN 通信软件和网络国际会议 目前，移动终端广泛应用于电力系统，容易成为攻击电力系统的目标或跳板。电力移动终端系统有必要进行安全评估，对潜在的风险进行预警。在此背景下，本文从通用移动终端安全评估体系和电源应用场景两个方面，构建了针对电力移动终端的安全评估体系。与现有方法相比，本文将机器学习引入到依赖专家经验的秩相关分析方法中，并利用客观的实验数据对指标的权重参数进行优化。通过实验证明，权值自学习方法可以用于电力移动终端系统的安全性评估，提高了结果的可信度。 一种移动终端的安全度量框架 2017 ICICTA 智能计算技术与自动化 随着移动互联网行业的快速发展，基于可信计算的信息安全问题也日益突出。鉴于现有的研究大多基于静态安全措施，本文基于服务器端和PC端，提出了一种基于移动终端的安全运行环境度量框架，以缓解移动终端普及带来的信息安全问题。该框架采用安全基线评审、环境漏洞检测、渗透测试、静态与动态结合应用安全测试四个功能模块，并通过实际测试发现，该测量框架能够很好地满足当前移动终端运行环境下对信息安全度量的需求 电力终端设备安全风险模型 2019 ISCID 计算智能与设计国际会议 基于物联网技术的我国电网系统的信息化发展正在急剧加快，由电力物联网网络互联的大量电力终端设备组成的电网系统。然而，随着网络攻击的不断变化和演变，面向网络空间安全的网络电源终端设备不断成为一个具有挑战性的问题。本文主要研究基于ATP攻击检测和防御的电力终端设备的安全风险及其漏洞。首先分析了基于电源终端设备的APT安全攻击机制。在分析电力物联网终端设备安全性和攻击问题的基础上，提出了一种基于本体的电力物联网终端设备及其漏洞知识表示方法 基于攻击树的智能终端风险分析 2016 CCIS 计算机与信息科学中的通信 前人对智能终端风险评估的研究较少。他们没有建立一个评估系统。以往关于智能终端安全评估的研究大多给出了系统安全性、不安全性和一般安全性的评估结果，没有给出最可能的攻击方式。如果管理者知道最可能的攻击方式，他们就会找到最薄弱的地方，从而保护这个系统。提出了一种基于攻击树的智能终端安全风险评估方案。它不仅可以评估系统的安全性，而且可以发现最可能的攻击路径。建立了基于攻击树的智能终端模型，利用概率风险评估技术计算了叶节点、根节点和攻击序列的发生概率。根节点的风险值可以根据攻击目标实现所造成的威胁值来计算。计算结果显示了根节点被攻击的概率，从而帮助风险管理人员发现智能终端中最薄弱的地方和最危险的攻击场景。计算结果也有效地为智能终端的安全性评估提供了依据。 基于隐私保护的多模型隐式身份验证协议的网联汽车智能终端 2020 IEEE Transactions on Intelligent Transportation Systems 车联网面临的最显著风险之一是智能终端安全。车载智能终端可对车载操作系统发起进一步攻击，渗透联网车内部网络，威胁车辆安全。因此，保护智能终端的安全至关重要。提出了两种基于智能终端的隐私保护多模态隐式认证协议来保护车载智能终端的安全。该协议以密码和车主行为特征作为认证因素，保护智能终端的安全。由于车主的行为特征是敏感的，必须保护用户的隐私信息，因此我们也考虑了行为特征的隐私保护。除了特征向量的密文大小外，我们的协议不会向认证服务器和对手透露任何有关车主行为特征的信息。我们分析了我们提出的协议的安全性，并在计算和通信成本方面与其他相关协议进行了比较。结果表明，我们提出的协议具有更好的安全性和效率。 RootAgency:面向云终端设备的基于数字签名的根权限管理机构 2018 sci information sciences 终端用户可能会出于各种动机，自愿ROOTAndroid设备，比如删除OEM预装应用。这导致了恶意软件特权升级的机会增加。现有的根权限管理方案依赖于最终用户，为设备上安装的所有合法和非法应用程序制定权限授予决定。然而,非技术用户不能,还是粗心在决定哪些特权适合什么类型的应用程序。为了解决这个问题,一个根特权管理机构命名RootAgency提出采用数字签名方案保证独家root-privilege-granting验证应用程序的机会。RootAgency通过检查应用程序是否持有由密钥生成的签名来验证其身份，并在签名的应用程序提交请求时授予root特权。此外，它还验证了应用程序的完整性，以防止它被重新打包。因此，用户在面对根请求时不需要参与决策。该方案既保证了Android根设备的安全，又增强了移动终端设备的安全性。这减少了Android设备根滥用对云基础设施的威胁。此外，还实现了一个原型来评估其有效性、效率和开销。实验结果表明，RootAgency具有广泛的兼容性和合理的性能开销。 SecureDroid:增强基于机器学习的Android恶意软件攻击检测的安全性 2017 ACSAC 计算机安全应用会议 在本文中，我们使用一种基于学习的分类器，输入从Android应用程序(apps)中提取的一组特征，探索机器学习在Android恶意软件检测中的安全性。我们考虑了与它们对分类问题的贡献相关的特征的不同重要性以及它们的操作成本，并提出了一种新的特征选择方法(称为SecCLS)，使分类器更难被回避。为了在不影响检测精度的同时提高系统安全性，我们进一步提出了一种集成学习方法(名为SecENS)，通过聚合使用我们提出的特征选择方法SecCLS构建的单个分类器。因此，我们开发了一个名为SecureDroid的系统，该系统集成了我们提出的方法(SecCLS和SecENS)，以增强基于机器学习的Android恶意软件检测的安全性。在Comodo云安全中心采集的真实样本上进行综合实验，通过与其他替代防御方法的比较，验证SecureDroid对对抗Android恶意软件攻击的有效性。我们提出的安全学习模式也可以很容易地应用于其他恶意软件检测任务。 ++团队主要在研究神经网络在Android设备安全中的应用++","link":"/2021/04/17/%E6%89%BE%E5%90%84%E7%A7%8D%E8%AE%BA%E6%96%87/"},{"title":"【Web安全】hydra,msf,nikto参数整理","text":"hydra1Syntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]] -l LOGIN or -L FILE login with LOGIN name, or load several logins from FILE -l 指定单个用户名，适合在知道用户名爆破用户名密码时使用 -L 指定多个用户名，参数值为存储用户名的文件的路径(建议为绝对路径) -p PASS or -P FILE try password PASS, or load several passwords from FILE -p 指定单个密码，适合在知道密码爆破用户名时使用 -P 指定多个密码，参数值为存贮密码的文件(通常称为字典)的路径(建议为绝对路径) -C FILE colon separated “login:pass” format, instead of -L/-P options当用户名和密码存储到一个文件时使用此参数。注意，文件(字典)存储的格式必须为 “用户名:密码” 的格式。 -M FILE list of servers to attack, one entry per line, ‘:’ to specify port指定多个攻击目标，此参数为存储攻击目标的文件的路径(建议为绝对路径)。注意：列表文件存储格式必须为 “地址:端口” -s port 非默认端口 可以-s设置端口 -o File 将结果写入文件中 12345hydra -l user -P passlist.txt ftp://192.168.0.1hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAINhydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5hydra -l admin -p password ftp://[192.168.0.0/24]/hydra -L logins.txt -P pws.txt -M targets.txt ssh MSFVENOM-p, –payload 指定需要使用的payload(有效载荷) -f, –format 指定输出格式 -e, –encoding 要使用的编码 用于编码加密 -a, –arch 指定payload的目标CPU架构(使用 –list archs 列出所有的CPU架构) –platform 指定payload的目标操作系统平台(使用 –list platforms 列出所有的操作系统平台) -o, –out 将payload保存到文件中 -i, –iterations 对payload进行编码的次数 -x, –template 指定一个可执行程序 将payload捆绑其中 例如:原先有个正常文件normal.exe 通过此选项把payload捆绑到这个程序上面 主要使用的也就是 -p -f -o -e -i 捆绑 -x -k 指定目标操作系统、cpu: -platform /-a //查询列表 – list encoders/payloads NIKTO–host 域名 –port 端口 -F（Format）+：指定检测报告输出文件的格式，默认是txt文件格式（可以是htm、csv、txt或xml格式）可以是csv,json,htm,nbe,sql,txt,xml -o（output）+：输出到指定文件 -t（timeout）+：超时时间，默认为2秒。 -T（Tuning）+：控制Nikto使用不同的方式对目标进行扫描： 12345678910111213140 检查文件上传页面1 检查Web日志2 检查错误配置或默认文件3 检查信息泄漏问题4 检查XSS/Script/HTML问题5 远程文件检索,从根目录检查是否存在可访问的文件6 检查拒绝服务问题7 远程文件检索,从任意文件检索是否存在可访问文件8 代码执行－远程shell,检查是否存在系统命令执行漏洞9 检查SQL注入漏洞a 检查认证绕过问题b 识别安装的软件版本c 检查源代码泄露问题x 反向链接选项 -e（evasion）+：使用LibWhisker中对IDS的躲避技术，可使用以下几种类型： 123456781 随机URL编码 （非UTF-8方式）2 自选择路径（/./）3 过早结束的URL4 优先考虑长随机字符串5 参数欺骗6 使用TAB作为命令的分隔符7 使用变化的URL8 使用Windows路径分隔符“\\”","link":"/2020/12/09/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86/"},{"title":"【论文】符号执行与符号虚拟机","text":"KLEE是一个建立在LLVM编译框架上的符号执行工具，它可以自动生成复杂和环境密集型程序的高覆盖率的测试用例。 传统的符号执行，动态符号执行，可选择的符号执行 传统的符号执行是一种静态的符号执行。它仅基于解析程序；输入变量被表示为模拟执行，而不是程序的实际执行。动态符号执行是符号执行和具体执行的结合，继承了两者的优点。研究人员可以执行选择性的符号执行，以在程序的某些区域上执行符号执行，其余的则执行特定的执行 基本原理 符号执行技术的基本原理是符号化程序的输入数据，即使用符号变量而不是实值来探索和解析程序。为了表示可能的执行流程，可以绘制程序的控制流程图(CFG)，以方便分析在执行过程中遍历的所有路径。此外，还可以创建一个引用到CFG的符号执行树，以记录与每个路径生成的程序输入变量关联的符号表达式 动态符号执行通过特定的输入来执行该程序。在收集约束的过程中，对输入变量进行顺序符号化，然后使用约束求解器来判断输入的变化，然后确定程序的下一个执行路径。除此之外，在程序的分支处，根据某些规则反转约束，并获得一个新的约束集。然后重复这种方法，尽可能多地遍历所有路径，以获得更高的覆盖率，值得一提的是，路径约束是通过每个分支约束的逻辑操作得到的一系列布尔表达式 KLEE KLEE是一个符号执行工具，用于检测程序漏洞，自动生成测试用例，实现高测试覆盖率。KLEE基于EXE[7]，其主要目标语言是C语言。 基本结构 KLEE在LLVM编译框架的情况下执行符号执行。生成一个执行测试主要涉及变量符号化、路径搜索和约束求解。变量通常通过在执行测试时调用程序中的klee_make_symbolic函数来表示。KLEE的解释组件执行代码的符号语义，并根据计算结果更新内存模型中的符号状态。内存模型组件跟踪符号状态，定义内存操作的语义，并处理特定的约束公式，以方便KLEE的决策和收集约束 执行完成后，编译器将源程序编译为LLVM[10]的中间语言。该语言有三个可互换的表达式：一个是LLVM字节码(.bc文件)，它是一种存储在硬盘上的二进制文件，可以通过KLEE命令直接执行。另一种是可读的中间格式(.ll文件)，具有较高的可读性，可以全面反映编译器内部数据的处理和传输。最后一种是内存中编译的中间语言 KLEE的约束解决 KLEE使用的约束求解器是STP。该过程主要是解决收集到的约束集，并以此来选择执行路径，解决变量值。首先，约束求解模块通过相关算法简化了约束集。例如，现有的条件(x&gt;5，x=6)可以简化为(x&gt;5)。然后，由于KLEE将约束描述为KQuery(KQuery语言是KLEE约束表达式的文本表示语言，其语法在执行过程[11]中由扩展的Bacchus范式表示)，因此将约束集转移到约束求解模块，并调用求解器的函数接口进行解析和转换约束。只有在将约束转换为求解器的语法描述格式后，才能启动求解过程。当上述步骤完成后，求解器通过一系列简化和转换的约束集表达式来求解结果","link":"/2021/08/04/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%AC%A6%E5%8F%B7%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"【Web安全】白帽子讲web安全笔记","text":"浏览器安全 同源策略 同源策略限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性 同源是指：协议，域名，端口号相同 js文件的源是加载他的域 对于浏览器来说，除了DOM，Cookie，XMLHttpRequest会受到同源策略限制外，一些第三方插件也有自己的同源策略，如Flash，Google Gears 浏览器沙箱 挂马：在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式 浏览器多进程架构，将浏览器各个功能隔开。 google主要进程分为浏览器进程，渲染进程，插件进程，扩展进程。渲染引擎由Sandbox隔离，页面代码要与浏览器内核进程通信、操作系统通信都需要通过IPC channel Sandbox：泛指“资源隔离类模块”，设计目的是为了让不信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源，如要跨越沙箱边界产生数据交换，只能通过指定数据通道，比如经过封装的API 采用沙箱技术，可以让不受信任的网页代码、js代码运行在一个受到限制的环境中，保护本地桌面系统安全。 恶意网址拦截 拦截恶意网站的功能是基于黑名单的 常见的恶意网站 挂马网站：包含恶意脚本如js或flash，通过利用浏览器漏洞，执行shellcode，在用户电脑植入木马 钓鱼网站：通过模仿知名网站的相似页面来欺骗用户 EVSSL证书：全球数据证书颁发机构与浏览器厂商一起打造的增强型证书。浏览器会给于EVSSL证书特殊待遇 跨站脚本攻击（xss）（未完） XSS简介 XSS攻击通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。 反射型XSS：简单的把用户输入的数据“反射”给浏览器，即黑客需要诱使用户“点击”一个恶意链接，才能攻击成功。“非持久型xss” 存储型XSS：将用户输入的数据“存储”在服务器端，这种xss具有很强的稳定性 DOM Based XSS：修改页面的DOM节点形成的XSS XSS防御 HttpOnly 在服务器发送set-cookie时标记，设置之后js读不到cookie值 解决的是XSS后的cookie劫持攻击 输入检查 一般是检查用户输入的数据中是否包含一些特殊字符-xss Filter ​ 有时候过滤会过滤掉用户本身的输入信息 当用户将恶意脚本的url输入时，无法filter，url被认为是合法的 输出检查 在变量输出到HTML页面时，可以使用编码或者转义字符来防御XSS ​ 安全的编码函数 HtmlEncode：针对HTML的编码方式。会对&amp; 〈 等字符进行转换，PHP中htmlentities()和htmlspecialchars()函数可以满足安全要求 JS中使用JavascriptEncode进行编码，使用\\进行转义，并要求输出的变量在引号内部 并不是在MVC的View层HtmlEncode所有变量就可以抵御XSS，XSS的防御需要分情况对待。 针对XSS可能发生的场景一一应对 xss本质是一种HTML注入，用户的数据被当成了HTML代码的一部分来执行，从而产生了新的语义。 在HTML标签中输出变量 可能攻击方式：xss一般会构造一个标签，或者任何能够产生脚本执行的方式： 防御方法：对变量使用HtmlEncode 在HTML属性中输出变量 可能攻击方式： 防御方式：HtmlEncode 还有OWASP ESAPI推荐的更严格的HtmlEncode，即除字母数字外，所有特殊字符都被编码成HTMLEntities 在标签中输出 可能攻击方式：攻击者将引号闭合 防御方式：JavascriptEncode 在CSS中输出 可能攻击方式： 防御方式：尽可能禁止用户可控制的变量在标签、HTML标签的style属性以及CSS文件中输出；还可以使用OWASP ESAPI中的encodeForCSS()函数 在地址中输出 可能攻击方式：如果用户能够控制整个url，则可以构造伪协议 防御方式：如果变量是整个url，则先检查变量是否以\"http\"开头，若不是则自动添加，在此之后再对变量进行URLEncode 处理富文本 网站需要用户提交自定义的HTML代码，称为富文本。比如在论坛中发帖子需要文字，图片视频，表格等。 过滤富文本时，“事件”应该被禁止，还有一些危险的标签，例如, , , 等。使用“白名单”原则，比如只允许, 等比较安全的标签存在 开源的XSS Filter：Anti-Samy，HTMLPurify 防御DOM Based XSS CSRF 简介 在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为\"one click\"攻击。 进阶 浏览器的cookie策略 session cookie：临时cookie，浏览器关闭后，session cookie就会失效 third-party cookie：本地cookie，服务器在set-cookie时会指定Expire时间，到了时间cookie才会失效。 P3P头 P3P头主要用于类似广告等需要跨域访问的页面。如果网站返回给浏览器的HTTP头中含有P3P头，则在某种程度上，将允许浏览器发送第三方cookie。（有些浏览器会拦截第三方cookie的发送，如IE和safari） csrf-get 对于一个表单来说，用户往往可以使用GET提交参数，例如： 攻击者可以构建如下html界面，让有登录状态的用户点击，即可造成csrf攻击 csrf-post 当网页使用POST方法时，例如： 可以直接构造form表单，然后用js自动化提交表单 防御 验证码 CSRF攻击的过程往往是在用户不知情的情况构成了网络请求，但验证码强制要求用户必须与应用进行交互。但是用户体验不佳 Referer Check 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://a.example/b，用户必须先登陆 a.example，然后通过点击页面上的按钮来触发事件。这时，该请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 a.example 域名开头的地址。而如果黑客要对网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，网站只需要对于每一个请求验证其 Referer 值，如果是以 a.example 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 缺点是服务器并非任何时候都能取到Referer，很多用户出于隐私考虑会限制Referer的发送。另外浏览器当从HTTPS转为HTTP时，也不会发送Referer Anti CSRF Token CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 在 HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 点击劫持（Click Jacking） 点击劫持（ClickJacking）是一种视觉上的欺骗手段。大概有两种方式，点击劫持（ClickJacking）是一种视觉上的欺骗手段。大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面；二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义； 防御 frame busting 通常可以写一段js代码来禁止iframe的嵌套，比如： 但有时候可以通过很多方式绕过，比如针对parent.location的，可以采用嵌套iframe的方式： X-Frame-Options 使用一个HTTP头——X-Frame-Options。X-Frame-Options可以说是为了解决ClickJacking而生的，它有三个可选的值： DENY：浏览器会拒绝当前页面加载任何frame页面； SAMEORIGIN：frame页面的地址只能为同源域名下的页面； ALLOW-FROM origin：允许frame加载的页面地址； 对于图片覆盖 在防御图片覆盖攻击时，需要检查用户提交的HTML代码中，img标签的style属性是否可能导致浮出 注入攻击（未完） 本质 用户可以控制输入 原本程序要执行的代码，拼接了用户输入的数据。 SQL注入 在SQL注入过程中，如果网站开启了错误回显，会为攻击者提供极大的便利（即输入非法数据，返回错误信息） 盲注 通过简单的条件判断等等方式判断注入是否存在 比如构造： 只输入2时页面正常显示，加上1=2后页面无法正常显示，即可能存在注入，此时也可能是网页的非法输入机制导致无法显示网页，再次构造，如果页面此时正常显示了，说明and语句执行了，存在注入 Timing Attack 在MySQL中，有一个BENCHMARK()函数，用来测试函数性能。比如BENCHMARK(count,expr) 函数执行的结果是将表达式expr执行count次，比如：select benchmark( 5000000, md5( 'test' ) ); 返回结果是0，耗时1.157秒。 文件上传漏洞 概述 文件上传漏洞是指用户上传了一个可执行的脚本文件，通过脚本获取了执行服务端命令的能力 文件上传后导致的常见安全问题有： 上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行； 上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似）； 上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行； 上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。 在大多数情况下，文件上传漏洞一般都是指“上传Web脚本能够被服务器解析”的问题，也就是通常所说的webshell的问题。要完成这个攻击，要满足如下几个条件： 首先，上传的文件能够被Web容器解释执行。所以文件上传后所在的目录要是Web容器所覆盖到的路径。 其次，用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法使得Web容器解释这个脚本，那么也不能称之为漏洞。 最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功 FCKEditor文件上传漏洞 通过检查文件后缀确定是否安全，（以黑名单的方式），黑名单是不好的设计思想 绕过文件上传检查 在针对上传文件的检查中，很多应用都是通过判断文件名后缀的方法来验证文件的安全性的。但是在某些时候，如果攻击者手动修改了上传过程的POST包，在文件名后添加一个%00字节，则可以截断某些函数对文件名的判断。因为在许多语言的函数中，比如在C、PHP等语言的常用字符串处理函数中，0x00被认为是终止符。 比如应用原本只允许上传JPG图片，那么可以构造文件名（需要修改POST包）为xxx.php[\\0].JPG，其中[\\0]为十六进制的0x00字符，.JPG绕过了应用的上传文件类型判断；但对于服务器端来说，此文件因为0字节截断的关系，最终却会变成xxx.php 有的应用，还会通过判断上传文件的文件头来验证文件的类型。浏览器的MINE Sniff功能就是通过读取文件的前256个字节来判断文件类型 有些漏洞是因为web server本身特性相关的功能导致的 Apache 1.x 2.x对文件名的解析是从后往前的直到遇到Apache认识的文件类型为止。这就会导致a.php.rar.rar.rar中，Apache不认识rar，会一直遍历到php IIS 6在文件解析时，当文件名为abc.asp;xx.jpg时，IIS会解析为abc.asp，文件名被截断了，导致脚本执行。 IIS支持PUT功能导致的上传脚本问题 PUT是在WebDav中定义的一个方法。WebDav大大扩展了HTTP协议中GET、POST、HEAD等功能，它所包含的PUT方法，允许用户上传文件到指定的路径下。 一般要实施此攻击过程，攻击者应先通过OPTIONS方法探测服务器支持的HTTP方法类型，如果支持PUT，则使用PUT上传一个指定的文本文件，最后再通过MOVE改写文件名称为脚本文件，如txt变php。 设计安全的文件上传功能 1. 文件上传的目录设置为不可执行 只要Web容器无法解析该目录下的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此此点至关重要。在实际应用中，很多大型网站的上传应用，文件上传后会放到独立的存储上，做静态文件处理，一方面方便使用缓存加速，降低性能损耗；另一方面也杜绝了脚本执行的可能。但是对于一些边边角角的小应用，如果存在文件上传功能，则仍需要多加关注。 2．判断文件类型 在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单的方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。 3．使用随机数改写文件名和文件路径 文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用使用随机数改写了文件名和路径，将极大地增加攻击的成本。与此同时，像shell.php.rar.rar这种文件，或者是crossdomain.xml这种文件，都将因为文件名被改写而无法成功实施攻击。 4．单独设置文件服务器的域名 由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含JavaScript的XSS利用等问题将得到解决。但能否如此设置，还需要看具体的业务环境。","link":"/2021/07/04/%E7%99%BD%E5%B8%BD%E5%AD%90/"},{"title":"【基础知识】计算机网络基础知识","text":"OSI七层模型与TCPIP四层五层模型的对应关系 OSI七层模型OSI七层模型为网络的标准层次划分 物理层物理层确保原始的数据可在各种物理媒体上传输 物理层设备：中继器 集线器 数据链路层数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 基本数据单位为帧； 主要的协议：以太网协议； 两个重要设备名称：网桥和交换机。 网络层网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 基本数据单位为IP数据报； 包含的主要协议： 1234IP协议（Internet Protocol，因特网互联协议）;ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;ARP协议（Address Resolution Protocol，地址解析协议）;RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 重要的设备：路由器。 传输层传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 包含的主要协议： 12TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 重要设备：网关。 会话层会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表示层表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 应用层应用层为操作系统或网络应用程序提供访问网络服务的接口。 数据传输基本单位为报文； 包含的主要协议： 123456FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 ARP协议地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 ARP工作流程举例： 12345678主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 路由选择协议OSPF协议与RIP协议 TCP协议三次握手四次挥手 UDPUDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 DNSDNS是域名系统(DomainNameSystem)的缩写，可以简单地理解为将URL转换为IP地址。 NAT NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术 DHCPDHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 HTTP协议超文本传输协议（HTTP，HyperText Transfer Protocol) GET与POST区别GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中.GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.","link":"/2021/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"【论文】论文结构的划分","text":"1. 题目方法 做什么 （eg 基于gin的入侵检测系统）读完题目要知道是做什么了 2. 摘要200-250词 要有因果关系和逻辑关系 摘要的结果部分可以把准确率放出来 不要写is low或者 is high 摘要的结构 1大背景 2现在的方案和不足 3基于不足提出自己的方法 4方法是啥 5方法结果 3. introduction1/6篇幅 （引用的也很多） 第一段 安全事件 面临的问题 第二段 现阶段的方法 方法有什么不好 第三段 提出我们的方法 然后论文的贡献 4. background概念 （算法方面可以加公式） realtedwork 要按照一定的规则插入引用论文 5. method（每一步的进行要有流程性） 我们的方法的overview of method 可以加个流程图 我们的方法论 实验 6. result准确率 效率（复杂度 时间效率） 与别的方法对比 不好的结果吧要说明原因 复杂度低的话可以拔高高度 比如可以应用在现实生活 7. conclusion8. reference重启一页 两边持平数量 引用 其他一些需要注意的点123456789101112131415图要表达明确 直观表用三线表（找图标 类似于搜car-icon）不要使用etc这种表达少用 our i we这种词准确率不要写is low或者 is high 缩写在正文第一次出现加上全称图和正文提及要使用交叉引用 图不要边框conception这个词不好与别人对比时 对比的应该是别人没解决的 我解决了贡献几个点都应该是完整的句子 contribution给出的应该是结果 图的字应该和文章的字颜色一样作图 ppt文章模板 word latex","link":"/2021/06/03/%E8%AE%BA%E6%96%87%E7%BB%93%E6%9E%84/"},{"title":"【算法】Leetcode题目记录","text":"数组二分法注意区间的左右开闭 移除元素我的想法：遍历过程中找到目标数 跟最后一个互换，然后在找到跟倒数第二个互换，最后的个数就是总的减去互换的 题解： 快慢指针 平方后排序：我的想法：找到正负分界点 分界点左和右向两边排序（太慢了） 题解：双指针 最大的数必定在数组的头和尾 快慢指针可以放在头和尾 倒序插入新数组 长度最小的子数组我的想法 ：暴力解法 题解：滑动窗口，重点是定义好窗口的边界如何变化。 ==注==：python生成无穷大的数 1234567python3.5以上import mathinf = math.infpython3.5以下inf = float('inf') 螺旋矩阵II而求解本题依然是要坚持循环不变量原则。 模拟顺时针画矩阵的过程: 填充上行从左到右填充右列从上到下填充下行从右到左填充左列从下到上由外向内一圈一圈这么画下去。 可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是一进循环深似海，从此offer是路人。 这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。 那么我按照左闭右开的原则，来画一圈，大家看一下： 这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。 这也是坚持了每条边左闭右开的原则。 一些同学做这道题目之所以一直写不好，代码越写越乱。 就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。 ==注:== python初始化二维数组： 123matrix = [[0] * n for _ in range(0, m)]matrix -&gt; [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] 链表移除元素注意不要出现None.next的情况 构造链表 注意使用虚拟头结点的话 不论添加还是删除操作都需要进行1self.head = dummy_node.next 此外 注意在头部和在尾部可以调用addatindex的逻辑 记得加一个链表的节点数属性翻转链表 双指针（迭代） 递归思想和双指针一致， 就是写法不一样，逻辑相同（内嵌函数，return函数）两辆交换链表中的节点 迭代记录前后指针 迭代 递归从后往前（很牛）删除链表的倒数第N个探针链表相交我的：我走过你走过的路 题解：求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，然后判断有无相等节点 环形链表II首先判断有没有环，然后确定环的入口，有没有环可以通过快慢指针来判断，（slow一次走一个，fast一次走两个）判断环的入口通过数学计算可以得到在快慢指针相遇时，定一个点，然后在链表开头定一个点 他们俩相遇的点就是环的入口点。 哈希表有效的字母异位词映射为hash表 两个数组的交集一个很厉害的写法 1list(set(nums1) &amp; set(nums2)) 快乐数注意题目中的会陷入无限循环所以需要加一个数组来记录出现的n，如果n重复出现了一定是陷入循环了，然后跳出 ==注==python获取数字的每一位 1234temp = []while n: temp.append(n % 10) n = n // 10 两数之和 三数之和双指针法： 拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。 依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。 接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。 如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。 时间复杂度：O(n^2)。 四数之和同样也是双指针的思路 N数之和都是将时间复杂度o(n ** N)变为o(n ** (N-1)) 赎金信我的想法：使用dict 更好的想法：在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！ 建一个大小为26的数组，使用ASCII码来对应每个字母 进行+1操作等 四数相加 ii 遍历1 2 数组，定义dic， key记录1和2元素的和 value记录出现次数 遍历 3 4 数组，判断 0-3-4是否在dic中，在的话result += dic[0-3-4] 字符串反转字符串双指针 反转字符串ii双指针 替换空格首先扩充数组到每个空格替换成”%20”之后的大小。 然后从后向前替换空格，也就是双指针法，过程如下： i指向新长度的末尾，j指向旧长度的末尾。 其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。 这么做有两个好处： 不用申请新数组。从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动 翻转字符串里的单词解题思路如下： 移除多余空格 将整个字符串反转 将每个单词反转 移除多余空格包括移除头 尾 中间的 中间的通过双指针的方式移除 左旋转字符串我的：申请了额外空间 题解： 可以使用切片时。使用切片 不可以使用的话： 反转区间为前n的子串 反转区间为n到末尾的子串 反转整个字符串 实现strStr()我的： 逐个元素切片判断相当 题解：KMP 注意next数组的获取中的while以及匹配过程中是needle在移动 而不是文本 重复的子字符串简单的： 1if s[0:x] * (len(s) // x) == s: 题解： next[len - 1] = 7，next[len - 1] + 1 = 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。 (len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。 栈与队列用栈实现队列使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈一个输入栈，一个输出栈，这里要注意输入栈和输出栈的关系 12345678910执行语句：queue.push(1);queue.push(2);queue.pop(); 注意此时的输出栈的操作queue.push(3);queue.push(4);queue.pop();queue.pop();注意此时的输出栈的操作queue.pop();queue.empty(); 用队列实现栈一个双向队列模拟队列时只能使用popleft（）和append（） 有效的括号使用栈的思想 删除字符串中的所有相邻重复项==递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。== 使用栈 在不可以使用栈的情况下可以使用双指针 双指针： 12345678910while fast &lt; length: # 如果一样直接换，不一样会把后面的填在slow的位置 res[slow] = res[fast] # 如果发现和前一个一样，就退一格指针 if slow &gt; 0 and res[slow] == res[slow - 1]: slow -= 1 else: slow += 1 fast += 1 逆波兰表达式求值后缀表达式的形式 使用栈 注意python中取整是向下取整-小数应该是向上取整 所以应该用math库中的ceil()函数 滑动窗口的最大值（单调队列） 没做前k个高频元素堆堆就是用数组实现的二叉树，所以它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。 堆的常用方法： 构建优先队列 支持堆排序 快速找出一个集合中的最小值（或者最大值） 堆分为最大堆和最小堆。在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。 这是一个最大堆，我们准备将上面例子中的树这样存储 1[ 10, 7, 2, 5, 1 ] 除了一个简单的数组以外，不需要任何额外的空间。如果 i 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置 123parent(i) = floor((i - 1)/2)left(i) = 2i + 1right(i) = 2i + 2 根节点(10)没有父节点，因为 -1 不是一个有效的数组索引。同样，节点 (2)，(5)和(1) 没有子节点，因为这些索引已经超过了数组的大小，所以我们在使用这些索引值的时候需要保证是有效的索引值。 题解我的： 统计数目的频数形成字典 对字典按照频数从大到小排序 输出前k个key 对字典使用value排序： 1234dic = {1: 3, 2: 2, 3: 1, 4: 1, 5: 1, 6: 2, 8: 2}dic = sorted(dic.items(),key =lambda item: item[1], reverse = True)print(dic)# [(1, 3), (2, 2), (6, 2), (8, 2), (3, 1), (4, 1), (5, 1)] 题解： 统计数目的频数形成字典 用最小堆，最小堆长度为k，当小于k时push，大于k时pop 输出最小堆 12345#用固定大小为k的小顶堆，扫面所有频率的数值for key, freq in map_.items(): heapq.heappush(pri_que, (freq, key)) if len(pri_que) &gt; k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k heapq.heappop(pri_que) 二叉树基础满二叉树如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。深度为k 节点为2 ** k - 1 完全二叉树在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。 二叉搜索树有数值 左小于根小于右 平衡二叉搜索树它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 二叉树的存储方式链式或者顺序，链式就是指针指向左右节点 顺序存储：如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2 二叉树的遍历方式深度优先： 前序 （递归 迭代） 中序 （递归 迭代） 后序 （递归 迭代） 广度优先： 层序遍历 迭代 栈其实就是递归的一种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。 广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树的递归遍历递归三部曲递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 二叉树的迭代遍历栈的思想 前序：前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。 中序： 后序： 二叉树的统一迭代法在要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 二叉树的层序遍历递归迭代：用队列 二叉树的层序遍历II用层序遍历后翻转结果列表 翻转二叉树递归：带函数的迭代：利用栈层序：利用队列 对称二叉树递归： 其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。 递归的函数传入的实际上是左右子树的对应节点 迭代 使用队列或栈都可以 二叉树的最大深度 n叉数的最大深度递归：前序遍历层序遍历 二叉树的最小深度递归：后序遍历层序遍历 平衡二叉树注意二叉树的高度的定义， 深度可以使用前序遍历 高度使用后序遍历左右中特殊例子： 12345 1 2 3 4 6 5 72的左子树高度2 右子树高度0 回溯回溯是递归的副产品，只要有递归就会有回溯。 回溯三部曲： 回溯函数模板返回值以及参数 回溯算法中函数返回值一般为void。 再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。 1void backtracking(参数) 回溯函数终止条件 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 1234if (终止条件) { 存放结果; return;} 回溯搜索的遍历过程 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。 12345for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果} 组合回溯 path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了 剪枝操作 图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。 所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。 如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。 分割回文串 and 复原ip地址回溯 分割约等于组合 贪心分发饼干小饼干优先分给小胃口 排序 摆动序列 和最大子序列和（没做）可用贪心和动态规划 买卖股票II贪心： 假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。 此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！ 跳跃游戏类似动态改变窗口大小 跳跃游戏2这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。 如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。 图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到） 12345678for i in range(len(nums)): nextDistance = max(i + nums[i], nextDistance) if i == curDistance: if curDistance != len(nums) - 1: ans += 1 curDistance = nextDistance if nextDistance &gt;= len(nums) - 1: break return ans 动态规划斐波那契数动态规划入门题 爬楼梯dp[i]表示爬i阶楼梯的方法数目 爬i阶相当于爬i-1阶再走一阶和爬i-2阶再走两阶 所以dp[i] = dp[i-1] + dp[i - 2] 用最小的花费爬楼梯dp[i]表示 从第i个楼梯开始爬的最小花费 dp[i] = min(dp[i-1], dp[i-2]) + cost[i] 最后取min(dp[-1], dp[-2]) 不同路径dp[i][j] 表示到i行j列位置的所有路径和 dp[0][j]和dp[i][0]都为1 dp[i][j] = dp[i-1][j] + dp[i][j-1] 不同路径2注意初始化的时候有障碍的后面全都赋值为0 另外注意起点和终点有障碍的情况 整数拆分确定下标意义：dp[i]：分拆出数字i，可以得到的最大乘积为dp[i]。 确定递推公式： 其实可以从1遍历j，然后有两种渠道得到dp[i]. 一个是j * (i - j) 直接相乘。 一个是j * dp[i - j] 可以理解为拆分为两个数和多个数 dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j}); 其中还要比较dp[i]的大小是因为j每次循环中都会给dp[i]赋值 我们要取大的。 初始化：dp[0], dp[1]赋值没有意义dp[2] = 1 确认遍历顺序dp[i]可以由dp[i-j]推导出来 所以是从前往后遍历 不同的二叉搜索树不同的二叉搜索树","link":"/2021/12/12/%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"},{"title":"test","text":"","link":"/2022/03/07/test/"}],"tags":[{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Web安全","slug":"Web安全","link":"/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[]}