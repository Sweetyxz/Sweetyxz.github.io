{"pages":[],"posts":[{"title":"【Python】Python基础知识","text":"变量和简单数据类型变量 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头 变量名不能包含空格，但可使用下划线来分隔其中的单词。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词， 变量名应既简短又具有描述性。例如，name比n好 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。 字符串 方法title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写 将字符串改为全部大写upper()或全部小写lower() 要在字符串中插入变量的值，可在前引号前加上字母f””，再将要插入的变量放在花括号内。这样，当Python显示字符串时，将把每个变量都替换为其值. 12name = &quot;Lily&quot;sen = f&quot;Hello {name}, I like Python very much&quot; 这种字符串名为f字符串。f是format（设置格式）的简写，因为Python通过把花括号内的变量替换为其值来设置字符串的格式 要在字符串中添加制表符，可使用字符组合\\t 要在字符串中添加换行符，可使用字符组合\\n 要确保字符串末尾没有空白，可使用方法rstrip(),你还可以剔除字符串开头的空白，或者同时剔除字符串两边的空白。为此，可分别使用方法lstrip()和strip() 数 Python使用两个乘号表示乘方运算 Python将所有带小数点的数称为浮点数 将任意两个数相除时，结果总是浮点数，即便这两个数都是整数且能整除： 无论是哪种运算，只要有操作数是浮点数，Python默认得到的总是浮点数，即便结果原本为整数也是如此 书写很大的数时，可使用下划线将其中的数字分组，使其更清晰易读 12a = 14_0000_0000print(a) -&gt; 1400000000 当你打印这种使用下划线定义的数时，Python不会打印其中的下划线 Python没有内置的常量类型，但Python程序员会使用全大写来指出应将某个变量视为常量，其值应始终不变12FAVORITE_NUM = 10print(&quot;最喜欢的数是：&quot; + str(FAVORITE_NUM)) 列表 列表由一系列按特定顺序排列的元素组成。在Python中，用方括号（[]）表示列表，并用逗号分隔其中的元素。 Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返回最后一个列表元素。这种约定也适用于其他负数索引。例如，索引-2返回倒数第二个列表元素，索引-3返回倒数第三个列表元素，依此类推 方法append()将元素添加到列表末尾 使用方法insert()可在列表的任何位置添加新元素 1insert(index, value) 如果知道要删除的元素在列表中的位置，可使用del语句。使用del可删除任意位置处的列表元素，条件是知道其索引 123# deldel names[1]print(names) 方法pop()删除列表末尾的元素，并让你能够接着使用它。术语弹出（pop）源自这样的类比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。实际上，可以使用pop()来删除列表中任意位置的元素，只需在圆括号中指定要删除元素的索引即可 12345678#pop()last_name = names.pop()print(last_name)print(names)# pop(index)second_name = names.pop(1)print(second_name)print(names) 如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()。 方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除 123#remove()names.remove('snn')print(names) Python方法sort()让你能够较为轻松地对列表进行排序。方法sort()永久性地修改列表元素的排列顺序。还可以按与字母顺序相反的顺序排列列表元素，只需向sort()方法传递参数reverse=True即可。 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]cars.sort()cars.sort(reverse = True) 要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()。如果要按与字母顺序相反的顺序显示列表，也可向函数sorted()传递参数reverse=True。 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]print(sorted(cars))print(sorted(cars, reverse = True)) 要反转列表元素的排列顺序，可使用方法reverse()。方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调用reverse()即可 123cars = [&quot;bmw&quot;, &quot;audi&quot;, &quot;toyota&quot;, &quot;subaru&quot;]cars.reverse()print(cars) 使用函数len()可快速获悉列表的长度 每当需要访问最后一个列表元素时，都可使用索引-1。仅当列表为空时，这种访问最后一个元素的方式才会导致错误 操作列表 Python根据缩进来判断代码行与前一个代码行的关系。 for语句末尾的冒号告诉Python，下一行是循环的第一行 Python函数range()让你能够轻松地生成一系列数。例如，可以像下面这样使用函数range()来打印一系列数。函数range()让Python从指定的第一个值开始数，并在到达你指定的第二个值时停止。 12nums = list(range(0,10))print(nums) 使用函数range()时，还可指定步长 12numss = list(range(0, 10, 2))print(numss) ==列表解析==将for循环和创建新元素的代码合并成一行，并自动附加新元素，请注意，这里的for语句末尾没有冒号 12squ = [value ** 2 for value in range(0, 3)]print(squ) 处理列表的部分元素，Python称之为==切片==，要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range()一样，Python在到达第二个索引之前的元素后停止。如果没有指定第一个索引，Python将自动从列表开头开始。 12345names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]print(names[0:3])print(names[:3])print(names[2:])print(names[-3:]) 可在表示切片的方括号内指定第三个值。这个值告诉Python在指定范围内每隔多少元素提取一个。 12names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]print(names[0:4:3]) 要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]） 12345names = [&quot;zyx&quot;, &quot;xxf&quot;, &quot;snn&quot;, &quot;nn&quot;]other_names = names[:] #复制列表使用切片 而非赋值other_names.append(&quot;lmy&quot;)print(other_names)print(names) ==使用赋值语句实际上是将两个变量指向同一个列表== Python将不能修改的值称为不可变的，而不可变的列表被称为==元组==，元组看起来很像列表，但使用圆括号而非中括号来标识。 123turp = (1,3)print(turp[0])print(turp[1]) 严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含一个元素的元组，必须在这个元素后面加上逗号。 12turp = (1,)print(turp[0]) 虽然不能修改元组的元素，但可以给存储元组的变量赋值 1234567turp = (1,3)print(turp[0])print(turp[1])turp = (2,5)print(turp[0])print(turp[1]) 如果需要存储的一组值在程序的整个生命周期内都不变，就可以使用元组 if语句 每条if语句的核心都是一个值为True或False的表达式，这种表达式称为==条件测试== 在Python中检查是否相等时区分大小写。 有时候需要在两个条件都为True时才执行相应的操作，而有时候只要求一个条件为True。在这些情况下，关键字and和or可助你一臂之力 要判断特定的值是否已包含在列表中，可使用关键字in。 还有些时候，确定特定的值未包含在列表中很重要。在这种情况下，可使用关键字not in。 Python只执行if-elif-else结构中的一个代码块 else是一条包罗万象的语句，只要不满足任何if或elif中的条件测试，其中的代码就会执行。这可能引入无效甚至恶意的数据。如果知道最终要测试的条件，应考虑使用一个elif代码块来代替else代码块 在运行for循环前确定列表是否为空很重要 在if语句中将列表名用作条件表达式时，Python将在列表至少包含一个元素时返回True，并在列表为空时返回False。 12345num = []if num: print(&quot;yes&quot;)else: print(&quot;no&quot;) 字典 在Python中，字典是一系列==键值对==。每个键都与一个值相关联，你可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。 在Python中，字典用放在花括号（{}）中的一系列键值对表示，键和值之间用冒号分隔，而键值对之间用逗号分隔 12name_age = {'zyx': 22, 'lmy': 23}print(name_age) 要获取与键相关联的值，可依次指定字典名和放在方括号内的键12name_age = {'zyx': 22, 'lmy': 23}print(name_age['zyx']) 字典是一种动态结构，可随时在其中添加键值对,要添加键值对，可依次指定字典名、用方括号括起的键和相关联的值 1234name_age = {'zyx': 22, 'lmy': 23}print(name_age)name_age['snn'] = 23 #新增键值对name_age['xxf'] = 23 对于字典中不再需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键.==删除的键值对会永远消失==。 123name_age = {'zyx': 22, 'lmy': 23}del name_age['lmy']print(name_age) 使用放在方括号内的键从字典中获取值时，可能会引发问题：如果指定的键不存在就会出错。方法get()的第一个参数用于指定键，是必不可少的；第二个参数为指定的键不存在时要返回的值，是可选的. 123name_age = {'zyx': 22, 'lmy': 23}other_name = name_age.get('nn', 'no such name') #get 方法print(other_name) 如果指定的键有可能不存在，应考虑使用方法get()，而不要使用方括号表示法7. for语句的第二部分包含字典名和方法items()，它返回一个键值对列表; 在不需要使用字典中的值时，方法keys()很有用。方法keys()并非只能用于遍历：实际上，它返回一个列表，其中包含字典中的所有键. 在只需要值时，使用方法values() 可使用函数sorted()来获得按特定顺序排列的键列表的副本. 最终的列表可能包含大量重复项。为剔除重复项，可使用集合（set）。集合中的每个元素都必须是独一无二的： 123456789101112my = {&quot;firstname&quot;: 'z', 'lastname': 'yx', &quot;age&quot;: 22, 'city': 'hangzhou', &quot;num&quot;: 22}for key,value in my.items():# 遍历键值对 print(f&quot;key is {key}&quot;) print(f&quot;value is {value}&quot;)for k in my.keys(): #只输出键 print(f&quot;key is {k}&quot;)for k in sorted(my.keys()): #排序后的键 print(f&quot;key is {k}&quot;)for v in my.values(): #只输出键 print(f&quot;value is {v}&quot;)for v in set(my.values()): #只输出键 print(f&quot;value is {v}&quot;) 可使用一对花括号直接创建集合，并在其中用逗号分隔元素（不含重复元素，集合） 12my = {1, 2, 3, 2} #集合print(my) 有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为==嵌套== 用户输入和while循环 函数input()接受一个参数——要向用户显示的提示（prompt）或说明，让用户知道该如何做。 12mes = input(&quot;输入姓名&quot;)print(mes) 使用函数input()时，Python将用户输入解读为字符串。将==数值输入用于计算和比较前，务必将其转换为数值==表示 求模运算符（%）是个很有用的工具，它将两个数相除并返回余数 12345num = input(&quot;input num: &quot;)if int(num) % 10 == 0: print(&quot;yes&quot;)else: print(&quot;no&quot;) 在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量称为==标志（flag）==，充当程序的交通信号灯 要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句 要返回循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环 for循环是一种遍历列表的有效方式，但不应在for循环中修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环","link":"/2021/06/23/Python/"},{"title":"【Go】Go基础知识","text":"Go的优势 可以直接编译成机器码 不依赖其他库 可以直接部署 静态类型语言 天生支持并发 充分利用多核 强大的标准库： runtime系统调度机制，高效的GC垃圾回收 丰富的标准库 Go的基础知识 定义变量：12var name typevar i int = 1 也可以让语言自行判定： 1var i = 1 或者： 1i := 1 这种只能在函数体内出现声明多变量： 1234567var( //一般用于声明全局变量 a int b string)var a, b = 1, '123' ==字符串用双引号==2. 常量定义 1const identifier [type] = value iota特殊常量 在同一个常量组中，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引) 12345const( a = iota //0 b //1 c //2) 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。如： 123456const ( a = 1 b //1 c //1 d //1) go中没有while循环 函数定义 1234567func function_name( [parameter list(type)] ) ([return_types]) { 函数体}func add(num1 string, num2 int) (string, int) { return num1, num2} ==闭包== Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。 12345678func getSequence() func() int { i:=0 return func() int { i+=1 return i }} 数组 声明数组 123var variable_name [SIZE] variable_typevar balance [10] float32 初始化数组 123456var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}数组长度不确定时var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}或balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 指针的定义 1234var var_name *var-typevar ip *int /* 指向整型*/var fp *float32 /* 指向浮点型 */ 指针数组 1var ptr [5]*int; 指向指针的指针 1var ptr **int 8.","link":"/2021/08/09/go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"【linux】linux常用命令","text":"chmod 更改文件权限 处理目录 1234567891011121314151617ls（英文全拼：list files）: 列出目录及文件名cd（英文全拼：change directory）：切换目录pwd（英文全拼：print workdirectory）：显示目前的目录mkdir（英文全拼：make directory）：创建一个新的目录rmdir（英文全拼：remove directory）：删除一个空的目录cp（英文全拼：copy file）: 复制文件或目录rm（英文全拼：remove）: 删除文件或目录mv（英文全拼：move file）:移动文件与目录，或修改文件与目录的名称 文件查看 1234567cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行 查看linux版本123查看操作系统版本信息 cat /proc/versionuname -auname -m 显示32位或64位 运行 Shell 脚本有两种方法： 作为可执行程序 12345将上面的代码保存为 test.sh，并 cd 到相应目录：chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 作为解释器参数 1234这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：/bin/sh test.sh/bin/php test.php","link":"/2021/06/02/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"【Python】乱起八糟的Python知识点","text":"Python内置的==enumerate==函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身 123456 for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C 可迭代对象可以直接作用于for循环的对象统称为可迭代对象：==Iterable==123456listtupledictsetstrgenerator 以及带yield的generator function 可使用isinstance()判断是否为可迭代对象 1234567891011&gt;&gt;&gt; from collections.abc import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 迭代器可以被next()函数调用并不断返回下一个值的对象称为迭代器：==Iterator==可以使用isinstance()判断一个对象是否是Iterator对象 123456789&gt;&gt;&gt; from collections.abc import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象4. reduce用法reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 123456from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 利用filter()求素数 12345678910111213141516171819202122232425def check_su(): n = 1 while True: n += 2 yield ndef fliter_fun(n): return lambda x: x % n &gt; 0def main(): yield 2 i = check_su() while True: n = next(i) yield n i = filter(fliter_fun(n), i)for n in main(): if n &lt; 100: print(n) else: break 装饰器 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 123456789101112131415161718192021def text_input(text): def log(func): @functools.wraps(func) def wrapper(*args, **kw): print(f&quot;call {func.__name__} {text}&quot;) return func(*args, **kw) return wrapper return log@text_input('8.15')def now(): print('2021')now()print(now.__name__)---call now 8.152021now 其中去掉@functools.wraps(func)，now.name会变成wrapper 动态绑定 动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现 1234567891011class student: passs = student()s.name = 'zyx' # 动态绑定新的属性def show_name(self, name): print(name)s.show_name = MethodType(show_name, s) # 给实例动态绑定方法 from types import MethodTypestudent.show_name = show_name # 动态绑定新的函数 slots 要限制实例的属性，比如只允许对Student实例添加name和age属性，可以定义一个特殊的__slots__变量，来限制该class实例能添加的属性 1234567class student: __slots__ = (name, age)s = student()s.name = 'zyx's.age = '22's.score = 5 # 报错 ==使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的== 9.@property 10.zip()函数","link":"/2021/08/17/%E4%B9%B1%E8%B5%B7%E5%85%AB%E7%B3%9F%E7%9A%84python%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"【Python】流畅的Python读书笔记","text":"切片的表达式 1object[start_index:end_index:step] step：正负数均可，其绝对值大小决定了切取数据时的‘‘步长”，而正负号决定了“切取方向”，正表示“从左往右”取值，负表示“从右往左”取值。当step省略时，默认为1，即从左往右以步长1取值。 sorted函数如果要按照某个规则排序，则需指定参数 key， key 是一个函数对象 例如字符串构成的列表，我想按照字符串的长度来排序 123chars = ['Andrew', 'This', 'a', 'from', 'is', 'string', 'test']print(sorted(chars, key=len)) 匿名函数 不需要显示的指定函数名 123calc = lambda n: n**nlambda表示匿名函数n表示函数参数 比如 123456789101112131415161718#这段代码def calc(x,y): return x**y#换成匿名函数calc = lambda x,y:x**yprint(calc(2,5))#三元运算def calc(x,y): if x &gt; y: return x*y else: return x / y #三元运算换成匿名函数calc = lambda x,y:x * y if x &gt; y else x / yprint(calc(2,5)) map()函数 map() 会根据提供的函数对指定序列做映射。 1map(function, iterable, ...) 第一个参数 function 以参数序列中的每一个元素调用 function 函数 123456789def square(x) : # 计算平方数... return x ** 2...&gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方&lt;map object at 0x100d3d550&gt; # 返回迭代器&gt;&gt;&gt; list(map(square, [1,2,3,4,5])) # 使用 list() 转换为列表[1, 4, 9, 16, 25]&gt;&gt;&gt; list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) # 使用 lambda 匿名函数[1, 4, 9, 16, 25] filter()函数 filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器对象。 1filter(function, iterable) 比如 123456def is_odd(n): return n % 2 == 1 tmplist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])newlist = list(tmplist)print(newlist) 迭代器与生成器 12345678910def test(): yield 1 a = 1 + 1 yield a yield 3res = test()print(next(res)) # 1print(next(res)) # 2print(res.__next__()) #3","link":"/2021/08/13/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"title":"【论文调研】符号执行与符号虚拟机","text":"KLEE是一个建立在LLVM编译框架上的符号执行工具，它可以自动生成复杂和环境密集型程序的高覆盖率的测试用例。 传统的符号执行，动态符号执行，可选择的符号执行 传统的符号执行是一种静态的符号执行。它仅基于解析程序；输入变量被表示为模拟执行，而不是程序的实际执行。动态符号执行是符号执行和具体执行的结合，继承了两者的优点。研究人员可以执行选择性的符号执行，以在程序的某些区域上执行符号执行，其余的则执行特定的执行 基本原理 符号执行技术的基本原理是符号化程序的输入数据，即使用符号变量而不是实值来探索和解析程序。为了表示可能的执行流程，可以绘制程序的控制流程图(CFG)，以方便分析在执行过程中遍历的所有路径。此外，还可以创建一个引用到CFG的符号执行树，以记录与每个路径生成的程序输入变量关联的符号表达式 动态符号执行通过特定的输入来执行该程序。在收集约束的过程中，对输入变量进行顺序符号化，然后使用约束求解器来判断输入的变化，然后确定程序的下一个执行路径。除此之外，在程序的分支处，根据某些规则反转约束，并获得一个新的约束集。然后重复这种方法，尽可能多地遍历所有路径，以获得更高的覆盖率，值得一提的是，路径约束是通过每个分支约束的逻辑操作得到的一系列布尔表达式 KLEE KLEE是一个符号执行工具，用于检测程序漏洞，自动生成测试用例，实现高测试覆盖率。KLEE基于EXE[7]，其主要目标语言是C语言。 基本结构 KLEE在LLVM编译框架的情况下执行符号执行。生成一个执行测试主要涉及变量符号化、路径搜索和约束求解。变量通常通过在执行测试时调用程序中的klee_make_symbolic函数来表示。KLEE的解释组件执行代码的符号语义，并根据计算结果更新内存模型中的符号状态。内存模型组件跟踪符号状态，定义内存操作的语义，并处理特定的约束公式，以方便KLEE的决策和收集约束 执行完成后，编译器将源程序编译为LLVM[10]的中间语言。该语言有三个可互换的表达式：一个是LLVM字节码(.bc文件)，它是一种存储在硬盘上的二进制文件，可以通过KLEE命令直接执行。另一种是可读的中间格式(.ll文件)，具有较高的可读性，可以全面反映编译器内部数据的处理和传输。最后一种是内存中编译的中间语言 KLEE的约束解决 KLEE使用的约束求解器是STP。该过程主要是解决收集到的约束集，并以此来选择执行路径，解决变量值。首先，约束求解模块通过相关算法简化了约束集。例如，现有的条件(x&gt;5，x=6)可以简化为(x&gt;5)。然后，由于KLEE将约束描述为KQuery(KQuery语言是KLEE约束表达式的文本表示语言，其语法在执行过程[11]中由扩展的Bacchus范式表示)，因此将约束集转移到约束求解模块，并调用求解器的函数接口进行解析和转换约束。只有在将约束转换为求解器的语法描述格式后，才能启动求解过程。当上述步骤完成后，求解器通过一系列简化和转换的约束集表达式来求解结果","link":"/2021/08/04/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%AC%A6%E5%8F%B7%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"论文调研","slug":"论文调研","link":"/tags/%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/"}],"categories":[]}